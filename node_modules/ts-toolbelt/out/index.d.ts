declare module "Number/Number" {
    /**
    A [[Number]]
    @example
    ```ts
    type number0 = '-42`
    type number1 = '420'
    ```
    */
    export type Number = string;
}
declare module "Iteration/IterationOf" {
    import { Number } from "Number/Number";
    /**
    Describes a map of number relationships
    (Generated with "./_Internal/IterationOfGenerator")
    @hidden
    */
    export type IterationMap = {
        '-40': ['__', '-39', '-40', -40, '-'];
        '-39': ['-40', '-38', '-39', -39, '-'];
        '-38': ['-39', '-37', '-38', -38, '-'];
        '-37': ['-38', '-36', '-37', -37, '-'];
        '-36': ['-37', '-35', '-36', -36, '-'];
        '-35': ['-36', '-34', '-35', -35, '-'];
        '-34': ['-35', '-33', '-34', -34, '-'];
        '-33': ['-34', '-32', '-33', -33, '-'];
        '-32': ['-33', '-31', '-32', -32, '-'];
        '-31': ['-32', '-30', '-31', -31, '-'];
        '-30': ['-31', '-29', '-30', -30, '-'];
        '-29': ['-30', '-28', '-29', -29, '-'];
        '-28': ['-29', '-27', '-28', -28, '-'];
        '-27': ['-28', '-26', '-27', -27, '-'];
        '-26': ['-27', '-25', '-26', -26, '-'];
        '-25': ['-26', '-24', '-25', -25, '-'];
        '-24': ['-25', '-23', '-24', -24, '-'];
        '-23': ['-24', '-22', '-23', -23, '-'];
        '-22': ['-23', '-21', '-22', -22, '-'];
        '-21': ['-22', '-20', '-21', -21, '-'];
        '-20': ['-21', '-19', '-20', -20, '-'];
        '-19': ['-20', '-18', '-19', -19, '-'];
        '-18': ['-19', '-17', '-18', -18, '-'];
        '-17': ['-18', '-16', '-17', -17, '-'];
        '-16': ['-17', '-15', '-16', -16, '-'];
        '-15': ['-16', '-14', '-15', -15, '-'];
        '-14': ['-15', '-13', '-14', -14, '-'];
        '-13': ['-14', '-12', '-13', -13, '-'];
        '-12': ['-13', '-11', '-12', -12, '-'];
        '-11': ['-12', '-10', '-11', -11, '-'];
        '-10': ['-11', '-9', '-10', -10, '-'];
        '-9': ['-10', '-8', '-9', -9, '-'];
        '-8': ['-9', '-7', '-8', -8, '-'];
        '-7': ['-8', '-6', '-7', -7, '-'];
        '-6': ['-7', '-5', '-6', -6, '-'];
        '-5': ['-6', '-4', '-5', -5, '-'];
        '-4': ['-5', '-3', '-4', -4, '-'];
        '-3': ['-4', '-2', '-3', -3, '-'];
        '-2': ['-3', '-1', '-2', -2, '-'];
        '-1': ['-2', '0', '-1', -1, '-'];
        '0': ['-1', '1', '0', 0, '0'];
        '1': ['0', '2', '1', 1, '+'];
        '2': ['1', '3', '2', 2, '+'];
        '3': ['2', '4', '3', 3, '+'];
        '4': ['3', '5', '4', 4, '+'];
        '5': ['4', '6', '5', 5, '+'];
        '6': ['5', '7', '6', 6, '+'];
        '7': ['6', '8', '7', 7, '+'];
        '8': ['7', '9', '8', 8, '+'];
        '9': ['8', '10', '9', 9, '+'];
        '10': ['9', '11', '10', 10, '+'];
        '11': ['10', '12', '11', 11, '+'];
        '12': ['11', '13', '12', 12, '+'];
        '13': ['12', '14', '13', 13, '+'];
        '14': ['13', '15', '14', 14, '+'];
        '15': ['14', '16', '15', 15, '+'];
        '16': ['15', '17', '16', 16, '+'];
        '17': ['16', '18', '17', 17, '+'];
        '18': ['17', '19', '18', 18, '+'];
        '19': ['18', '20', '19', 19, '+'];
        '20': ['19', '21', '20', 20, '+'];
        '21': ['20', '22', '21', 21, '+'];
        '22': ['21', '23', '22', 22, '+'];
        '23': ['22', '24', '23', 23, '+'];
        '24': ['23', '25', '24', 24, '+'];
        '25': ['24', '26', '25', 25, '+'];
        '26': ['25', '27', '26', 26, '+'];
        '27': ['26', '28', '27', 27, '+'];
        '28': ['27', '29', '28', 28, '+'];
        '29': ['28', '30', '29', 29, '+'];
        '30': ['29', '31', '30', 30, '+'];
        '31': ['30', '32', '31', 31, '+'];
        '32': ['31', '33', '32', 32, '+'];
        '33': ['32', '34', '33', 33, '+'];
        '34': ['33', '35', '34', 34, '+'];
        '35': ['34', '36', '35', 35, '+'];
        '36': ['35', '37', '36', 36, '+'];
        '37': ['36', '38', '37', 37, '+'];
        '38': ['37', '39', '38', 38, '+'];
        '39': ['38', '40', '39', 39, '+'];
        '40': ['39', '__', '40', 40, '+'];
        '__': ['__', '__', string, number, '-' | '0' | '+'];
    };
    /**
    Transform a number into an [[Iteration]]
    (to use [[Prev]], [[Next]], & [[Pos]])
    @param N to transform
    @returns [[Iteration]]
    @example
    ```ts
    import {I} from 'ts-toolbelt'
    
    type i = I.IterationOf<'0'> // ["-1", "1", "0", 0, "0"]
    
    type next = I.Next<i>       // ["0", "2", "1", 1, "+"]
    type prev = I.Prev<i>       // ["-2", "0", "-1", -1, "-"]
    
    type nnext = I.Pos<next>    // +1
    type nprev = I.Pos<prev>    // -1
    ```
    */
    export type IterationOf<N extends Number> = N extends keyof IterationMap ? IterationMap[N] : IterationMap['__'];
}
declare module "Iteration/Iteration" {
    import { IterationMap } from "Iteration/IterationOf";
    /**
    An entry of **`IterationMap`**
    * `[0]`: Prev (<-)
    * `[1]`: Next (->)
    * `[2]`: Current **`string`**
    * `[3]`: Current **`number`**
    * `[4]`: Sign (- / 0 / +)
    */
    export type Iteration = [keyof IterationMap, keyof IterationMap, string, number, '-' | '0' | '+'];
}
declare module "Iteration/Next" {
    import { IterationMap } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    /**
    Move **`I`**'s position forward
    @param I to move
    @returns [[Iteration]]
    @example
    ```ts
    import {I} from 'ts-toolbelt'
    
    type i = I.IterationOf<'20'>
    
    type test0 = I.Pos<i>         // 20
    type test1 = I.Pos<I.Next<i>> // 21
    ```
    */
    export type Next<I extends Iteration> = IterationMap[I[1]];
}
declare module "List/List" {
    /**
    A [[List]]
    @param A its type
    @returns [[List]]
    @example
    ```ts
    type list0 = [1, 2, 3]
    type list1 = number[]
    ```
    */
    export type List<A = any> = ReadonlyArray<A>;
}
declare module "List/Prepend" {
    import { List } from "List/List";
    /**
    Add an element **`A`** at the beginning of **`L`**
    @param L to append to
    @param A to be added to
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Prepend<L extends List, A extends any> = ((head: A, ...args: L) => any) extends ((...args: infer U) => any) ? U : L;
}
declare module "Any/Cast" {
    /**
     * Ask TS to re-check that **`A1`** extends **`A2`**.
     * And if it fails, **`A2`** will be enforced anyway.
     * Can also be used to add constraints on parameters.
     * @param A1 to check against
     * @param A2 to cast **`A1`** to
     * @returns **`A1`** or **`A2`**
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Cast<'42', string> // '42'
     * type test1 = A.Cast<'42', number> // number
     * ```
     */
    export type Cast<A1 extends any, A2 extends any> = A1 extends A2 ? A1 : A2;
}
declare module "Iteration/_Internal" {
    /**
    Describes compatible type formats
    * `s`: **`string`**
    * `n`: **`number`**
    */
    export type Formats = 'n' | 's';
    /**
    Describes how to perform iterations
    */
    export type Way = '->' | '<-';
}
declare module "Iteration/Format" {
    import { Iteration } from "Iteration/Iteration";
    import { Formats } from "Iteration/_Internal";
    /**
    Is [[Key]] and [[Pos]] in a single type
    @param I to query
    @param fmt output format
    @returns **`string | number`**
    @example
    ```ts
    import {I} from 'ts-toolbelt'
    
    /// Let's make '20' an iteration
    type i = I.IterationOf<'20'> // [...]
    
    type fmtS = I.Fmt<i, 's'> // '20'
    type fmtN = I.Fmt<i, 'n'> //  20
    ```
    */
    export type Format<I extends Iteration, fmt extends Formats> = {
        's': I[2];
        'n': I[3];
    }[fmt];
}
declare module "Iteration/Key" {
    import { Iteration } from "Iteration/Iteration";
    import { Format } from "Iteration/Format";
    /**
    Get the position of **`I`** (**string**)
    @param I to query
    @returns [[String]]
    @example
    ```ts
    import {I} from 'ts-toolbelt'
    
    type i = I.IterationOf<'20'>
    
    type test0 = I.Key<i>         // '20'
    type test1 = I.Key<I.Next<i>> // '21'
    ```
    */
    export type Key<I extends Iteration> = Format<I, 's'>;
}
declare module "Object/Overwrite" {
    /**
    Update the fields of **`O`** with the ones of **`O1`**
    (only the existing fields will be updated)
    @param O to update
    @param O1 to update with
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Overwrite<O extends object, O1 extends object> = {
        [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
    } & {};
}
declare module "List/_Internal" {
    /** @ignore */ /** */
    import { Overwrite } from "Object/Overwrite";
    import { List } from "List/List";
    /**
    Remove `?` & `readonly` from a [[List]]
     */
    export type Naked<L extends List> = Overwrite<Required<L>, L>;
}
declare module "Any/Extends" {
    /**
     * Check whether **`A1`** is part of **`A2`** or not. The difference with
     * `extends` is that it forces a [[Boolean]] return.
     * @param A1
     * @param A2
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Extends<'a' | 'b', 'b'> // Boolean
     * type test1 = A.Extends<'a', 'a' | 'b'> // True
     *
     * type test2 = A.Extends<{a: string}, {a: any}>      // True
     * type test3 = A.Extends<{a: any}, {a: any, b: any}> // False
     *
     * type test4 = A.Extends<never, never> // False
     * /// Nothing cannot extend nothing, use `A.Equals`
     * ```
     */
    export type Extends<A1 extends any, A2 extends any> = [A1] extends [never] ? 0 : A1 extends A2 ? 1 : 0;
}
declare module "List/Repeat" {
    import { Next } from "Iteration/Next";
    import { Prepend } from "List/Prepend";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    import { Cast } from "Any/Cast";
    import { Key } from "Iteration/Key";
    import { List } from "List/List";
    import { Naked } from "List/_Internal";
    import { Extends } from "Any/Extends";
    /**
    @hidden
    */
    type __Repeat<N extends Number, A, L extends List = [], I extends Iteration = IterationOf<'0'>> = {
        0: __Repeat<N, A, Prepend<L, A>, Next<I>>;
        1: L;
    }[Extends<N, Key<I>>];
    /**
    @hidden
    */
    export type _Repeat<A extends any, N extends Number, L extends List = []> = __Repeat<N, A, Naked<L>> extends infer X ? Cast<X, List> : never;
    /**
    Fill a [[List]] with **`N`** times **`A`**
    @param A to fill with
    @param N to repeat it
    @param L (?=`[]`) to be filled
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Repeat<A extends any, N extends Number, L extends List = []> = N extends unknown ? L extends unknown ? _Repeat<A, N, L> : never : never;
}
declare module "Any/Equals" {
    /**
     * Check whether **`A1`** is equal to **`A2`** or not.
     * @param A1
     * @param A2
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Equals<42 | 0, 42 | 0>                    // true
     * type test1 = A.Equals<{a: string}, {b: string}>          // false
     * type test3 = A.Equals<{a: string}, {readonly a: string}> // false
     * ```
     */
    export type Equals<A1 extends any, A2 extends any> = (<A>() => A extends A1 ? 1 : 0) extends (<A>() => A extends A2 ? 1 : 0) ? 1 : 0;
}
declare module "Any/Compute" {
    /**
     * Force TS to load a type that has not been computed (to resolve composed
     * types that TS haven't fully resolved, for display purposes mostly).
     * @param A to compute
     * @returns **`A`**
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Compute<{x: 'x'} & {y: 'y'}> // {x: 'x', y: 'y'}
     * ```
     */
    export type Compute<A extends any> = A extends Function ? A : {
        [K in keyof A]: A[K];
    } & {};
}
declare module "Boolean/Boolean" {
    /**
    A [[Boolean]]
    */
    export type Boolean = True | False;
    /**
    1
    */
    export type True = 1;
    /**
    0
    */
    export type False = 0;
}
declare module "Test" {
    import { Repeat } from "List/Repeat";
    import { Equals } from "Any/Equals";
    import { Compute } from "Any/Compute";
    import { True, False, Boolean } from "Boolean/Boolean";
    /**
    Test should pass
    */
    export type Pass = True;
    /**
    Test should fail
    */
    export type Fail = False;
    /**
    Check or test the validity of a type
    @param debug to debug with parameter hints (`ctrl+p`, `ctrl+shift+space`)
    @example
    ```ts
    // see in `tst` folder
    ```
    */
    export function check<Type, Expect, Outcome extends Boolean>(debug?: Compute<Type>): Equals<Equals<Type, Expect>, Outcome>;
    /**
    Validates a batch of [[check]]
    @param checks a batch of [[check]]
    @example
    ```ts
    // see in `tst` folder
    ```
    */
    export function checks(checks: Partial<Repeat<Pass, '30'>>): void;
}
declare module "Any/Key" {
    /**
     * Describes index keys for any type
     */
    export type Key = string | number | symbol;
}
declare module "Object/Pick" {
    import { Key } from "Any/Key";
    /**
    @hidden
    */
    type __Pick<O extends object, K extends keyof O> = {
        [P in K]: O[P];
    } & {};
    /**
    @hidden
    */
    export type _Pick<O extends object, K extends Key> = __Pick<O, keyof O & K>;
    /**
    Extract out of **`O`** the fields of key **`K`**
    @param O to extract from
    @param K to chose fields
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Pick<O extends object, K extends Key> = O extends unknown ? _Pick<O, K & keyof O> : never;
}
declare module "Union/Union" {
    /**
    A [[Union]]
    @example
    ```ts
    type union0 = 1 | 2 | 3
    type union1 = 'a' | 420
    ```
    */
    export type Union = any;
}
declare module "Union/Exclude" {
    import { Union } from "Union/Union";
    /**
    Remove **`M`** out of **`U`**
    @param U to remove from
    @param M to remove out
    @returns [[Union]]
    @example
    ```ts
    ```
    */
    export type Exclude<U extends Union, M extends Union> = U extends M ? never : U;
}
declare module "Union/Keys" {
    import { Union } from "Union/Union";
    import { Key } from "Any/Key";
    /**
    Get the keys of a [[Union]]
    @param U
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type Keys<U extends Union> = (U extends unknown ? keyof U : never) & Key;
}
declare module "Object/Keys" {
    import { Keys as UKeys } from "Union/Keys";
    /**
    Get the keys of an [[Object]]
    @param O
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type Keys<O extends object> = UKeys<O>;
}
declare module "Object/Omit" {
    import { _Pick } from "Object/Pick";
    import { Exclude } from "Union/Exclude";
    import { Key } from "Any/Key";
    import { Keys } from "Object/Keys";
    export type _Omit<O extends object, K extends Key> = _Pick<O, Exclude<Keys<O>, K>>;
    /**
    Remove out of **`O`** the fields of key **`K`**
    @param O to remove from
    @param K to chose fields
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Omit<O extends object, K extends Key> = O extends unknown ? _Omit<O, K> : never;
}
declare module "Object/At" {
    import { Key } from "Any/Key";
    import { Boolean } from "Boolean/Boolean";
    /**
    @hidden
    */
    type AtStrict<O extends object, K extends Key> = [K & keyof O] extends [never] ? never : O[K & keyof O];
    /**
    @hidden
    */
    type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
    /**
    Get in **`O`** the type of a field of key **`K`**
    @param O to extract from
    @param K to extract at
    @param strict (?=`1`) `0` to work with unions
    @returns **`any`**
    @example
    ```ts
    import {O} from 'ts-toolbelt'
    
    type User = {
        info: {
            name: string
            age: number
            payment: {}
        }
        id: number
    }
    
    type test0 = O.At<User, 'id'> // number
    ```
    */
    export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
        1: AtStrict<O, K>;
        0: AtLoose<O, K>;
    }[strict];
}
declare module "Number/_Internal" {
    import { IterationMap } from "Iteration/IterationOf";
    import { Format } from "Iteration/Format";
    /**
    Describes compatible type formats
    * `b`: **`boolean`**
    * `n`: **`number`**
    * `s`: **`string`**
    */
    export type Formats = 'b' | 'n' | 's';
    /**
    @hidden
    */
    type KnownIterationMapKeys = '-40' | '-39' | '-38' | '-37' | '-36' | '-35' | '-34' | '-33' | '-32' | '-31' | '-30' | '-29' | '-28' | '-27' | '-26' | '-25' | '-24' | '-23' | '-22' | '-21' | '-20' | '-19' | '-18' | '-17' | '-16' | '-15' | '-14' | '-13' | '-12' | '-11' | '-10' | '-9' | '-8' | '-7' | '-6' | '-5' | '-4' | '-3' | '-2' | '-1' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12' | '13' | '14' | '15' | '16' | '17' | '18' | '19' | '20' | '21' | '22' | '23' | '24' | '25' | '26' | '27' | '28' | '29' | '30' | '31' | '32' | '33' | '34' | '35' | '36' | '37' | '38' | '39' | '40';
    /**
    @hidden
    */
    type PositiveIterationKeys = '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12' | '13' | '14' | '15' | '16' | '17' | '18' | '19' | '20' | '21' | '22' | '23' | '24' | '25' | '26' | '27' | '28' | '29' | '30' | '31' | '32' | '33' | '34' | '35' | '36' | '37' | '38' | '39' | '40';
    /**
    @hidden
    */
    type NegativeIterationKeys = '-40' | '-39' | '-38' | '-37' | '-36' | '-35' | '-34' | '-33' | '-32' | '-31' | '-30' | '-29' | '-28' | '-27' | '-26' | '-25' | '-24' | '-23' | '-22' | '-21' | '-20' | '-19' | '-18' | '-17' | '-16' | '-15' | '-14' | '-13' | '-12' | '-11' | '-10' | '-9' | '-8' | '-7' | '-6' | '-5' | '-4' | '-3' | '-2' | '-1';
    /**
    Describes known values of a **number**
    @hidden
    */
    export type Numbers = {
        'string': {
            'all': Format<IterationMap[KnownIterationMapKeys], 's'>;
            '+': Format<IterationMap[PositiveIterationKeys], 's'>;
            '-': Format<IterationMap[NegativeIterationKeys], 's'>;
            '0': Format<IterationMap['0'], 's'>;
        };
        'number': {
            'all': Format<IterationMap[KnownIterationMapKeys], 'n'>;
            '+': Format<IterationMap[PositiveIterationKeys], 'n'>;
            '-': Format<IterationMap[NegativeIterationKeys], 'n'>;
            '0': Format<IterationMap['0'], 'n'>;
        };
    };
}
declare module "Iteration/Pos" {
    import { Iteration } from "Iteration/Iteration";
    import { Format } from "Iteration/Format";
    /**
    Get the position of **`I`** (**number**)
    @param I to query
    @returns **`number`**
    @example
    ```ts
    import {I} from 'ts-toolbelt'
    
    type i = I.IterationOf<'20'>
    
    type test0 = I.Pos<i>         // 20
    type test1 = I.Pos<I.Next<i>> // 21
    ```
    */
    export type Pos<I extends Iteration> = Format<I, 'n'>;
}
declare module "Number/NumberOf" {
    import { IterationMap } from "Iteration/IterationOf";
    import { Key } from "Iteration/Key";
    import { Pos } from "Iteration/Pos";
    import { Numbers } from "Number/_Internal";
    /**
    @hidden
    */
    export type _NumberOf<N extends number> = {
        [K in keyof IterationMap]: Pos<IterationMap[K]> extends N ? Key<IterationMap[K]> : never;
    }[keyof IterationMap];
    /**
    Transform a **`number`** into a [[Number]]
    @param N to stringify
    @returns [[String]]
    @example
    ```ts
    import {N} from 'ts-toolbelt'
    
    type test0 = N.StringOf<5>  //  '5'
    type test1 = N.StringOf<-5> // '-5'
    ```
    */
    export type NumberOf<N extends number> = N extends Numbers['number']['all'] ? _NumberOf<N> : string;
}
declare module "List/Length" {
    import { NumberOf } from "Number/NumberOf";
    import { Formats } from "Iteration/_Internal";
    import { List } from "List/List";
    /**
    Get the length of **`L`**
    @param L to get length
    @param fmt (?=`'n'`) output format
    @returns [[String]] or **`number`**
    @example
    ```ts
    ```
    */
    export type Length<L extends List, fmt extends Formats = 'n'> = {
        's': NumberOf<L['length']>;
        'n': L['length'];
    }[fmt];
}
declare module "List/Reverse" {
    import { Prepend } from "List/Prepend";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Length } from "List/Length";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    import { Naked } from "List/_Internal";
    import { Extends } from "Any/Extends";
    /**
    @hidden
    */
    type __Reverse<L extends List, LO extends List, I extends Iteration = IterationOf<'0'>> = {
        0: __Reverse<L, Prepend<LO, L[Pos<I>]>, Next<I>>;
        1: LO;
    }[Extends<Pos<I>, Length<L>>];
    /**
    @hidden
    */
    export type _Reverse<L extends List, LO extends List = []> = __Reverse<Naked<L>, LO> extends infer X ? Cast<X, List> : never;
    /**
    Turn a [[List]] the other way around
    @param L to reverse
    @param LO (?=`[]`) to prepend to
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Reverse<L extends List, LO extends List = []> = L extends unknown ? LO extends unknown ? _Reverse<L, LO> : never : never;
}
declare module "List/Concat" {
    import { _Reverse } from "List/Reverse";
    import { List } from "List/List";
    /**
    @hidden
    */
    export type _Concat<L extends List, L1 extends List> = _Reverse<_Reverse<L>, L1>;
    /**
    Attach **`L1`** at the end of **`L`**
    @param L to concat with
    @param L1 to be attached
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Concat<L extends List, L1 extends List> = L extends unknown ? L1 extends L1 ? _Concat<L, L1> : never : never;
}
declare module "List/Append" {
    import { _Concat } from "List/Concat";
    import { List } from "List/List";
    /**
    @hidden
    */
    export type _Append<L extends List, A extends any> = _Concat<L, [A]>;
    /**
    Add an element **`A`** at the end of **`L`**
    @param L to append to
    @param A to be added to
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Append<L extends List, A extends any> = L extends unknown ? A extends unknown ? _Append<L, A> : never : never;
}
declare module "Object/ListOf" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Cast } from "Any/Cast";
    import { Key } from "Iteration/Key";
    import { Next } from "Iteration/Next";
    import { _Append } from "List/Append";
    import { Exclude } from "Union/Exclude";
    import { List } from "List/List";
    import { Extends } from "Any/Extends";
    /**
    @hidden
    */
    type PickIfEntry<O extends object, LN extends List, I extends Iteration> = Key<I> extends keyof O ? _Append<LN, O[Cast<Key<I>, keyof O>]> : LN;
    /**
    @hidden
    */
    type __ListOf<O extends object, K, LN extends List = [], I extends Iteration = IterationOf<'0'>> = {
        0: __ListOf<O, Exclude<K, Key<I>>, PickIfEntry<O, LN, I>, Next<I>>;
        1: LN;
    }[Extends<[K], [never]>];
    /**
    @hidden
    */
    export type _ListOf<O extends object> = __ListOf<O, keyof O> extends infer X ? Cast<X, List> : never;
    /**
    Transform an [[Object]] into a [[List]]
    (It will only pick numeric literal indexes)
    @param O to transform
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type ListOf<O extends object> = O extends unknown ? _ListOf<O> : never;
}
declare module "Boolean/Not" {
    import { Boolean } from "Boolean/Boolean";
    /**
    Logical **`!`** operator (behaves like the JS one)
    @param B to negate
    @returns [[Boolean]]
    @example
    ```ts
    import {B} from 'ts-toolbelt'
    
    type test0 = B.Not<B.True>  // False
    type test1 = B.Not<B.False> // True
    ```
    */
    export type Not<B extends Boolean> = {
        0: 1;
        1: 0;
    }[B];
}
declare module "Union/Has" {
    import { Union } from "Union/Union";
    import { Not } from "Boolean/Not";
    import { Extends } from "Any/Extends";
    /**
    Check whether **`U`** contains **`U1`**
    @param U to be inspected
    @param U1 to check within
    @returns [[Boolean]]
    @example
    ```ts
    ```
    */
    export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;
}
declare module "Any/Clean" {
    import { _Omit } from "Object/Omit";
    import { _Pick } from "Object/Pick";
    import { At } from "Object/At";
    import { Exclude } from "Union/Exclude";
    import { Numbers } from "Number/_Internal";
    import { _ListOf } from "Object/ListOf";
    import { Has } from "Union/Has";
    /**
     * @hidden
     */
    type ArrayEntry = Numbers['string']['0' | '+'];
    /**
     * @hidden
     */
    type ArrayProps = keyof any[] | ArrayEntry;
    /**
     * Sometimes, we can end up with mixed up **`objects`** that do not make sense
     * visually (or that could at least be simplified for the end user). This will
     * turn anything that is passed to it into a cleaned up [[Object]].
     *
     * @param O
     * @returns [[Object]]
     * @example
     * ```ts
     * ```
     */
    export type Clean<A extends any> = A extends object ? Has<keyof A, keyof any[]> extends 1 ? [Exclude<keyof A, ArrayProps>] extends [never] ? number extends At<A, 'length'> ? At<A, number>[] : A : number extends At<A, 'length'> ? _Omit<A, ArrayProps> & At<A, number>[] : At<A, 'length'> extends number ? _Omit<A, ArrayProps> & _ListOf<_Pick<A, ArrayEntry>> : A : A : A;
}
declare module "Any/Implements" {
    import { Extends } from "Any/Extends";
    /**
     * Check whether **`A1`** is part of **`A2`** or not. It works like
     * [[Extends]] but [[Boolean]] results are narrowed to [[False]].
     * @param A1
     * @param A2
     * @returns [[Boolean]]
     * @example
     * ```ts
     * type test0 = A.Implements<'a' | 'b', 'b'> // False
     * type test1 = A.Implements<'a', 'a' | 'b'> // True
     *
     * type test2 = A.Implements<{a: string}, {a: any}>      // True
     * type test3 = A.Implements<{a: any}, {a: any, b: any}> // False
     *
     * type test4 = A.Implements<never, never> // False
     * /// Nothing cannot implement nothing, use `A.Equals`
     * ```
     */
    export type Implements<A1 extends any, A2 extends any> = Extends<A1, A2> extends 1 ? 1 : 0;
}
declare module "Any/_Internal" {
    import { _NumberOf } from "Number/NumberOf";
    /**
     * Describes the match strategy when matching types
     * * `default`   : `extends->`
     * * `contains->`: X contains Y
     * * `extends->` : X extends  Y
     * * `<-contains`: Y contains X
     * * `<-extends` : Y extends  X
     * * `equals`    : X equals   Y
     */
    export type Match = 'default' | 'implements->' | '<-implements' | 'extends->' | '<-extends' | 'equals';
    /**
     * @hidden
     */
    export type NumberOf<N extends any> = N extends number ? _NumberOf<N> : N;
}
declare module "Any/Is" {
    import { Match } from "Any/_Internal";
    import { Extends } from "Any/Extends";
    import { Equals } from "Any/Equals";
    import { Implements } from "Any/Implements";
    /**
     * Check whether `A` is similar to `A1` or not. In other words, it is a compact
     * type that bundles `Equals`, `Extends` and `Implements` comparison types.
     * @param A to be compared
     * @param A1 to compare to
     * @param match (?=`'default'`) to change precision
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Is<'a', 'a' | 'b', 'extends->'> // True
     * type test1 = A.Is<'a' | 'b', 'a', 'extends->'> // Boolean
     *
     * type test2 = A.Is<'a', 'a' | 'b', '<-extends'> // Boolean
     * type test3 = A.Is<'a' | 'b', 'a', '<-extends'> // True
     *
     * type test4 = A.Is<'a', 'a' | 'b', 'implements->'> // True
     * type test5 = A.Is<'a' | 'b', 'a', 'implements->'> // False
     *
     * type test6 = A.Is<'a', 'a' | 'b', '<-implements'> // False
     * type test7 = A.Is<'a' | 'b', 'a', '<-implements'> // True
     *
     * type test8 = A.Is<'a', 'a' | 'b', 'equals'>      // False
     * type test9 = A.Is<'b' |'a', 'a' | 'b', 'equals'> // True
     * ```
     */
    export type Is<A extends any, A1 extends any, match extends Match = 'default'> = {
        'default': Extends<A, A1>;
        'implements->': Implements<A, A1>;
        'extends->': Extends<A, A1>;
        '<-implements': Implements<A1, A>;
        '<-extends': Extends<A1, A>;
        'equals': Equals<A1, A>;
    }[match];
}
declare module "Any/Kind" {
    import { Extends } from "Any/Extends";
    import { List } from "List/List";
    /**
     * Get the literal kind of a type
     * @param A
     * @returns **`'string' | 'number' | 'function' | 'array' | 'object' | 'boolean' | 'unknown'`**
     * @example
     * ```ts
     * ```
     */
    export type Kind<A extends any> = Extends<A, Function> extends 1 ? 'function' : Extends<A, List> extends 1 ? 'array' : Extends<A, object> extends 1 ? 'object' : Extends<A, string> extends 1 ? 'string' : Extends<A, number> extends 1 ? 'number' : Extends<A, boolean> extends 1 ? 'boolean' : 'unknown';
}
declare module "List/ObjectOf" {
    import { _Omit } from "Object/Omit";
    import { Has } from "Union/Has";
    import { At } from "Object/At";
    import { List } from "List/List";
    /**
    @hidden
    */
    export type _ObjectOf<L extends object> = Has<keyof L, keyof List> extends 1 ? number extends At<L, 'length'> ? _Omit<L, Exclude<keyof any[], number>> : _Omit<L, keyof any[]> : L;
    /**
    Transform a [[List]] or an `Array` into an [[Object]]
    @param L to transform
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type ObjectOf<L extends object> = L extends unknown ? _ObjectOf<L> : never;
}
declare module "List/Omit" {
    import { _Omit as _OOmit } from "Object/Omit";
    import { _ListOf } from "Object/ListOf";
    import { Key } from "Any/Key";
    import { List } from "List/List";
    import { _ObjectOf } from "List/ObjectOf";
    import { NumberOf } from "Any/_Internal";
    /**
    @hidden
    */
    export type _Omit<L extends List, K extends Key> = _ListOf<_OOmit<_ObjectOf<L>, NumberOf<K>>>;
    /**
    Remove out of **`L`** the entries of key **`K`**
    @param L to remove from
    @param K to chose entries
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Omit<L extends List, K extends Key> = L extends unknown ? _Omit<L, K> : never;
}
declare module "Any/Omit" {
    import { _Omit as _OOmit } from "Object/Omit";
    import { _Omit as _LOmit } from "List/Omit";
    import { Key } from "Any/Key";
    import { List } from "List/List";
    import { Union } from "Union/Union";
    /**
     * Remove out from each member of union **`U`** the fields of key **`K`**
     * @param U to remove from
     * @param K to chose fields
     * @returns [[Union]]
     * @example
     * ```ts
     * import {U} from 'ts-toolbelt'
     *
     * type O = {type: 'foo'; other: number} | {type: 'bar'; other: string} | [0, 1]
     * type test0 = U.Omit<O, 'other' | '0'> // {type: 'foo'} | {type: 'bar'} | [1]
     * ```
     */
    export type Omit<U extends Union, K extends Key> = U extends object ? U extends List ? _LOmit<U, K> : _OOmit<U, K> : U;
}
declare module "List/Pick" {
    import { _Pick as _OPick } from "Object/Pick";
    import { _ListOf } from "Object/ListOf";
    import { Key } from "Any/Key";
    import { _ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    import { NumberOf } from "Any/_Internal";
    /**
    @hidden
    */
    export type _Pick<L extends List, K extends Key> = _ListOf<_OPick<_ObjectOf<L>, NumberOf<K>>>;
    /**
    Extract out of **`L`** the entries of key **`K`**
    @param L to extract from
    @param K to chose entries
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Pick<L extends List, K extends Key> = L extends unknown ? _Pick<L, K> : never;
}
declare module "Any/Pick" {
    import { _Pick as _OPick } from "Object/Pick";
    import { _Pick as _LPick } from "List/Pick";
    import { Key } from "Any/Key";
    import { List } from "List/List";
    import { Union } from "Union/Union";
    /**
     * Extract out from each member of union **`U`** the fields of key **`K`**
     * @param U to remove from
     * @param K to chose fields
     * @returns [[Union]]
     * @example
     * ```ts
     * import {U} from 'ts-toolbelt'
     *
     * type O = {type: 'foo'; other: number} | {type: 'bar'; other: string} | [0, 1]
     * type test0 = U.Pick<O, 'type' | '1'> // {type: 'foo'} | {type: 'bar'} | [1]
     * ```
     */
    export type Pick<U extends Union, K extends Key> = U extends object ? U extends List ? _LPick<U, K> : _OPick<U, K> : U;
}
declare module "Any/Promisable" {
    /**
     * A way to say that you can handle **`Promises`** and non-**`Promises`**. This
     * is often the case if you're a heavy user of `await` and `async`.
     * @param A **`A`** A type
     * @returns **`A | Promise<A>`**
     * @example
     */
    export type Promisable<A extends any> = A | Promise<A>;
}
declare module "Any/Try" {
    /**
     * Similar to [[Cast]] but with a custom fallback **`Catch`**. If it fails,
     * it will enforce **`Catch`** instead of **`A2`**.
     * @param A1 to check against
     * @param A2 to try **`A1`** with
     * @param Catch to fallback (fail)
     * @returns **`A1`** or **`Catch`**
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Try<'42', string>          // '42'
     * type test1 = A.Try<'42', number>          // never
     * type test1 = A.Try<'42', number, 'tried'> // 'tried'
     * ```
     */
    export type Try<A1 extends any, A2 extends any, Catch = never> = A1 extends A2 ? A1 : Catch;
}
declare module "Any/Type" {
    const symbol: unique symbol;
    /**
     * Create your own named sub-type from a type **`A`**
     * @param A to be personalized
     * @param Id to name the sub-type
     * @returns A new type **`Type<A, Name>`**
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type EUR = Type<number, 'eur'>
     * type USD = Type<number, 'usd'>
     *
     * let eurWallet = 10 as EUR
     * let usdWallet = 15 as USD
     *
     * eurWallet = usdWallet // error
     * ```
     */
    export type Type<A extends any, Id extends string> = A & {
        [K in typeof symbol]: Id;
    };
}
declare module "Any/x" {
    import { Type } from "Any/Type";
    /**
     * A placeholder that is used in various ways
     */
    export type x = Type<{}, 'x'>;
}
declare module "Any/_api" {
    /** @ignore */ /** */
    export { Cast } from "Any/Cast";
    export { Clean } from "Any/Clean";
    export { Compute } from "Any/Compute";
    export { Equals } from "Any/Equals";
    export { Extends } from "Any/Extends";
    export { Implements } from "Any/Implements";
    export { Key } from "Any/Key";
    export { Is } from "Any/Is";
    export { Kind } from "Any/Kind";
    export { Omit } from "Any/Omit";
    export { Pick } from "Any/Pick";
    export { Promisable } from "Any/Promisable";
    export { Try } from "Any/Try";
    export { Type } from "Any/Type";
    export { x } from "Any/x";
}
declare module "Boolean/And" {
    import { Boolean } from "Boolean/Boolean";
    /**
    Logical **`&&`** operator (behaves like the JS one)
    @param B1 Left-hand side
    @param B2 Right-hand side
    @returns [[Boolean]]
    @example
    ```ts
    import {B} from 'ts-toolbelt'
    
    type test0 = B.And<B.True, B.False>          // False
    type test1 = B.And<B.True, B.True>           // True
    type test2 = B.And<B.True | B.False, B.True> // Boolean
    ```
    */
    export type And<B1 extends Boolean, B2 extends Boolean> = {
        0: {
            0: 0;
            1: 0;
        };
        1: {
            0: 0;
            1: 1;
        };
    }[B1][B2];
}
declare module "Boolean/BooleanOf" {
    /**
    Transform a **`boolean`** into a [[Boolean]]
    @param B to transform
    @returns [[Boolean]]
    @example
    ```ts
    type test0 = B.BooleanOf<true>  // 1
    type test1 = B.BooleanOf<false> // 0
    ```
    */
    export type BooleanOf<B extends boolean> = B extends true ? 1 : 0;
}
declare module "Boolean/_Internal" {
    /**
    Describes compatible type formats
    * `b`: **`boolean`**
    * `n`: **`number`**
    * `s`: **`string`**
    */
    export type Formats = 'b' | 'n' | 's';
}
declare module "Boolean/Format" {
    import { Boolean } from "Boolean/Boolean";
    import { Formats } from "Boolean/_Internal";
    /**
    Change the format of a [[Boolean]]
    @param B to transform
    @returns **`string | number | boolean`**
    @example
    ```ts
    import {B} from 'ts-toolbelt'
    
    type test0 = B.Format<B.True, 's'> // 'true'
    type test1 = B.Format<B.True, 'b'> //  true
    ```
    */
    export type Format<B extends Boolean, fmt extends Formats> = {
        'b': [false, true][B];
        'n': B;
        's': ['false', 'true'][B];
    }[fmt];
}
declare module "Boolean/Or" {
    import { Boolean } from "Boolean/Boolean";
    /**
    Logical **`||`** operator (behaves like the JS one)
    @param B1 Left-hand side
    @param B2 Right-hand side
    @returns [[Boolean]]
    @example
    ```ts
    import {B} from 'ts-toolbelt'
    
    type test0 = B.Or<B.True, B.False>    // True
    type test1 = B.Or<B.True, B.True>     // True
    type test2 = B.Or<B.Boolean, B.False> // Boolean
    ```
    */
    export type Or<B1 extends Boolean, B2 extends Boolean> = {
        0: {
            0: 0;
            1: 1;
        };
        1: {
            0: 1;
            1: 1;
        };
    }[B1][B2];
}
declare module "Boolean/Xor" {
    import { Boolean } from "Boolean/Boolean";
    /**
    Logical **`^`** operator (behaves like the JS one)
    @param B1 Left-hand side
    @param B2 Right-hand side
    @returns [[Boolean]]
    @example
    ```ts
    import {B} from 'ts-toolbelt'
    
    type test0 = B.Xor<B.True, B.True>    // False
    type test1 = B.Xor<B.False, B.True>   // True
    type test2 = B.Xor<B.Boolean, B.True> // Boolean
    ```
    */
    export type Xor<B1 extends Boolean, B2 extends Boolean> = {
        0: {
            0: 0;
            1: 1;
        };
        1: {
            0: 1;
            1: 0;
        };
    }[B1][B2];
}
declare module "Boolean/_api" {
    /** @ignore */ /** */
    export { And } from "Boolean/And";
    export { True, False, Boolean } from "Boolean/Boolean";
    export { BooleanOf } from "Boolean/BooleanOf";
    export { Format } from "Boolean/Format";
    export { Not } from "Boolean/Not";
    export { Or } from "Boolean/Or";
    export { Xor } from "Boolean/Xor";
}
declare module "Class/Class" {
    import { List } from "List/List";
    /**
    Alias to create/describe a [[Class]]
    @param P its constructor parameters
    @param R the object it constructs
    */
    export type Class<P extends List = any, R extends object = any> = new (...args: P) => R;
}
declare module "Class/InstanceOf" {
    import { Class } from "Class/Class";
    /**
    Get the instance type of a **`class`** from a class object
    @param C **typeof** **`class`**
    @returns **`class`**
    @example
    ```ts
    import {C} from 'ts-toolbelt'
    
    /// `create` takes an instance constructor and creates an instance of it
    declare function create<C extends (new (...args: any[]) => any)>(c: C): C.InstanceOf<C>
    
    class A {}
    class B {}
    
    let a = create(A) // A
    let b = create(B) // B
    ```
    */
    export type InstanceOf<C extends Class> = C extends new (...args: any[]) => infer R ? R : any;
}
declare module "Class/Parameters" {
    import { Class } from "Class/Class";
    /**
    Get the parameters of a class constructor
    @param C **typeof** **`class`**
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Parameters<C extends Class> = C extends Class<infer P, any> ? P : never;
}
declare module "Class/PromiseOf" {
    /**
    Get the instance type wrapped within a **`Promise`**
    @param P **`Promise`**
    @returns **`any`**
    @example
    ```ts
    import {C} from 'ts-toolbelt'
    
    const promise = new Promise<string>((res, rej) => res('x'))
    
    type test0 = C.PromiseOf<typeof promise>  // string
    type test1 = C.PromiseOf<Promise<number>> // number
    ```
    */
    export type PromiseOf<P extends any> = P extends Promise<infer A> ? A : P;
}
declare module "Class/_api" {
    /** @ignore */ /** */
    export { Class } from "Class/Class";
    export { InstanceOf } from "Class/InstanceOf";
    export { Parameters } from "Class/Parameters";
    export { PromiseOf } from "Class/PromiseOf";
}
declare module "Function/_Internal" {
    /**
    Describes function modes
    * `sync` : Normal function
    * `async`: Promised result
    */
    export type Mode = 'sync' | 'async';
    /**
    Describes function parameter input
    * `multi`: ( a, b, c ... n ) => X
    * `list` : ([a, b, c ... n]) => X
    */
    export type Input = 'multi' | 'list';
}
declare module "Function/Function" {
    import { List } from "List/List";
    /**
    Alias to create a [[Function]]
    @param P parameters
    @param R return type
    @returns [[Function]]
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    type test0 = F.Function<[string, number], boolean>
    /// (args_0: string, args_1: number) => boolean
    ```
    */
    export interface Function<P extends List = any, R extends any = any> {
        (...args: P): R;
    }
}
declare module "Function/Return" {
    import { Function } from "Function/Function";
    /**
    Extract the return type of a [[Function]]
    @param F to extract from
    @returns **`any`**
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    const fn = () => true
    
    type test0 = F.ReturnOf<typeof fn>  // boolean
    
    type test1 = F.ReturnOf<() => true> // true
    ```
    */
    export type Return<F extends Function> = F extends ((...args: any[]) => infer R) ? R : never;
}
declare module "List/Tail" {
    import { List } from "List/List";
    /**
    Remove the first item out of a [[List]]
    @param L
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Tail<L extends List> = ((...t: L) => any) extends ((head: any, ...tail: infer LTail) => any) ? LTail : never;
}
declare module "List/Last" {
    import { Tail } from "List/Tail";
    import { Length } from "List/Length";
    import { List } from "List/List";
    /**
    Get the last entry of **`L`**
    @param L to extract from
    @returns **`any`**
    @example
    ```ts
    ```
    */
    export type Last<L extends List> = L[Length<Tail<L>>];
}
declare module "List/Head" {
    import { Length } from "List/Length";
    import { List } from "List/List";
    /**
    Get the first entry of **`L`**
    @param L to extract from
    @returns **`any`**
    @example
    ```ts
    ```
    */
    export type Head<L extends List> = Length<L> extends 0 ? never : L[0];
}
declare module "Function/Compose/Multi/Sync" {
    /** @ignore */ /** */
    import { Function } from "Function/Function";
    import { Return } from "Function/Return";
    import { Last } from "List/Last";
    import { Head } from "List/Head";
    /**
    @hidden
     */
    export type ComposeMultiSync = {
        <R0, P extends any[]>(...fns: [Function<P, R0>]): Function<P, R0>;
        <R0, R1, P extends any[]>(...fns: [Function<[R0], R1>, Function<P, R0>]): Function<P, R1>;
        <R0, R1, R2, P extends any[]>(...fns: [Function<[R1], R2>, Function<[R0], R1>, Function<P, R0>]): Function<P, R2>;
        <R0, R1, R2, R3, P extends any[]>(...fns: [Function<[R2], R3>, Function<[R1], R2>, Function<[R0], R1>, Function<P, R0>]): Function<P, R3>;
        <R0, R1, R2, R3, R4, P extends any[]>(...fns: [Function<[R3], R4>, Function<[R2], R3>, Function<[R1], R2>, Function<[R0], R1>, Function<P, R0>]): Function<P, R4>;
        <R0, R1, R2, R3, R4, R5, P extends any[]>(...fns: [Function<[R4], R5>, Function<[R3], R4>, Function<[R2], R3>, Function<[R1], R2>, Function<[R0], R1>, Function<P, R0>]): Function<P, R5>;
        <R0, R1, R2, R3, R4, R5, R6, P extends any[]>(...fns: [Function<[R5], R6>, Function<[R4], R5>, Function<[R3], R4>, Function<[R2], R3>, Function<[R1], R2>, Function<[R0], R1>, Function<P, R0>]): Function<P, R6>;
        <R0, R1, R2, R3, R4, R5, R6, R7, P extends any[]>(...fns: [Function<[R6], R7>, Function<[R5], R6>, Function<[R4], R5>, Function<[R3], R4>, Function<[R2], R3>, Function<[R1], R2>, Function<[R0], R1>, Function<P, R0>]): Function<P, R7>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, P extends any[]>(...fns: [Function<[R7], R8>, Function<[R6], R7>, Function<[R5], R6>, Function<[R4], R5>, Function<[R3], R4>, Function<[R2], R3>, Function<[R1], R2>, Function<[R0], R1>, Function<P, R0>]): Function<P, R8>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, P extends any[]>(...fns: [Function<[R8], R9>, Function<[R7], R8>, Function<[R6], R7>, Function<[R5], R6>, Function<[R4], R5>, Function<[R3], R4>, Function<[R2], R3>, Function<[R1], R2>, Function<[R0], R1>, Function<P, R0>]): Function<P, R9>;
        <Fns extends Function[]>(...fns: Fns): Function<Parameters<Last<Fns>>, Return<Head<Fns>>>;
    };
}
declare module "Function/Compose/Multi/Async" {
    /** @ignore */ /** */
    import { Function } from "Function/Function";
    import { PromiseOf } from "Class/PromiseOf";
    import { Last } from "List/Last";
    import { Return } from "Function/Return";
    import { Head } from "List/Head";
    /**
    @hidden
     */
    export type ComposeMultiAsync = {
        <R0, P extends any[]>(...fns: [Function<P, R0>]): Function<P, Promise<PromiseOf<R0>>>;
        <R0, R1, P extends any[]>(...fns: [Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R1>>>;
        <R0, R1, R2, P extends any[]>(...fns: [Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R2>>>;
        <R0, R1, R2, R3, P extends any[]>(...fns: [Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R3>>>;
        <R0, R1, R2, R3, R4, P extends any[]>(...fns: [Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R4>>>;
        <R0, R1, R2, R3, R4, R5, P extends any[]>(...fns: [Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R5>>>;
        <R0, R1, R2, R3, R4, R5, R6, P extends any[]>(...fns: [Function<[PromiseOf<R5>], R6>, Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R6>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, P extends any[]>(...fns: [Function<[PromiseOf<R6>], R7>, Function<[PromiseOf<R5>], R6>, Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R7>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, P extends any[]>(...fns: [Function<[PromiseOf<R7>], R8>, Function<[PromiseOf<R6>], R7>, Function<[PromiseOf<R5>], R6>, Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R8>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, P extends any[]>(...fns: [Function<[PromiseOf<R8>], R9>, Function<[PromiseOf<R7>], R8>, Function<[PromiseOf<R6>], R7>, Function<[PromiseOf<R5>], R6>, Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R9>>>;
        <Fns extends Function[]>(...fns: Fns): Function<Parameters<Last<Fns>>, Promise<PromiseOf<Return<Head<Fns>>>>>;
    };
}
declare module "Function/Compose/List/Sync" {
    /** @ignore */ /** */
    import { Function } from "Function/Function";
    import { Return } from "Function/Return";
    import { Last } from "List/Last";
    import { Head } from "List/Head";
    /**
    @hidden
     */
    export type ComposeListSync = {
        <R0, P extends any[]>(fns: [Function<P, R0>]): Function<P, R0>;
        <R0, R1, P extends any[]>(fns: [Function<[R0], R1>, Function<P, R0>]): Function<P, R1>;
        <R0, R1, R2, P extends any[]>(fns: [Function<[R1], R2>, Function<[R0], R1>, Function<P, R0>]): Function<P, R2>;
        <R0, R1, R2, R3, P extends any[]>(fns: [Function<[R2], R3>, Function<[R1], R2>, Function<[R0], R1>, Function<P, R0>]): Function<P, R3>;
        <R0, R1, R2, R3, R4, P extends any[]>(fns: [Function<[R3], R4>, Function<[R2], R3>, Function<[R1], R2>, Function<[R0], R1>, Function<P, R0>]): Function<P, R4>;
        <R0, R1, R2, R3, R4, R5, P extends any[]>(fns: [Function<[R4], R5>, Function<[R3], R4>, Function<[R2], R3>, Function<[R1], R2>, Function<[R0], R1>, Function<P, R0>]): Function<P, R5>;
        <R0, R1, R2, R3, R4, R5, R6, P extends any[]>(fns: [Function<[R5], R6>, Function<[R4], R5>, Function<[R3], R4>, Function<[R2], R3>, Function<[R1], R2>, Function<[R0], R1>, Function<P, R0>]): Function<P, R6>;
        <R0, R1, R2, R3, R4, R5, R6, R7, P extends any[]>(fns: [Function<[R6], R7>, Function<[R5], R6>, Function<[R4], R5>, Function<[R3], R4>, Function<[R2], R3>, Function<[R1], R2>, Function<[R0], R1>, Function<P, R0>]): Function<P, R7>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, P extends any[]>(fns: [Function<[R7], R8>, Function<[R6], R7>, Function<[R5], R6>, Function<[R4], R5>, Function<[R3], R4>, Function<[R2], R3>, Function<[R1], R2>, Function<[R0], R1>, Function<P, R0>]): Function<P, R8>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, P extends any[]>(fns: [Function<[R8], R9>, Function<[R7], R8>, Function<[R6], R7>, Function<[R5], R6>, Function<[R4], R5>, Function<[R3], R4>, Function<[R2], R3>, Function<[R1], R2>, Function<[R0], R1>, Function<P, R0>]): Function<P, R9>;
        <Fns extends Function[]>(fns: Fns): Function<Parameters<Last<Fns>>, Return<Head<Fns>>>;
    };
}
declare module "Function/Compose/List/Async" {
    /** @ignore */ /** */
    import { Function } from "Function/Function";
    import { PromiseOf } from "Class/PromiseOf";
    import { Last } from "List/Last";
    import { Return } from "Function/Return";
    import { Head } from "List/Head";
    /**
    @hidden
     */
    export type ComposeListAsync = {
        <R0, P extends any[]>(fns: [Function<P, R0>]): Function<P, Promise<PromiseOf<R0>>>;
        <R0, R1, P extends any[]>(fns: [Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R1>>>;
        <R0, R1, R2, P extends any[]>(fns: [Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R2>>>;
        <R0, R1, R2, R3, P extends any[]>(fns: [Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R3>>>;
        <R0, R1, R2, R3, R4, P extends any[]>(fns: [Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R4>>>;
        <R0, R1, R2, R3, R4, R5, P extends any[]>(fns: [Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R5>>>;
        <R0, R1, R2, R3, R4, R5, R6, P extends any[]>(fns: [Function<[PromiseOf<R5>], R6>, Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R6>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, P extends any[]>(fns: [Function<[PromiseOf<R6>], R7>, Function<[PromiseOf<R5>], R6>, Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R7>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, P extends any[]>(fns: [Function<[PromiseOf<R7>], R8>, Function<[PromiseOf<R6>], R7>, Function<[PromiseOf<R5>], R6>, Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R8>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, P extends any[]>(fns: [Function<[PromiseOf<R8>], R9>, Function<[PromiseOf<R7>], R8>, Function<[PromiseOf<R6>], R7>, Function<[PromiseOf<R5>], R6>, Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R0>], R1>, Function<P, R0>]): Function<P, Promise<PromiseOf<R9>>>;
        <Fns extends Function[]>(fns: Fns): Function<Parameters<Last<Fns>>, Promise<PromiseOf<Return<Head<Fns>>>>>;
    };
}
declare module "String/_Internal" {
    /**
    Describes compatible type formats
    * `b`: **`boolean`**
    * `s`: **`string`**
    * `n`: **`number`**
    */
    export type Formats = 'b' | 'n' | 's';
}
declare module "String/Format" {
    import { Formats } from "String/_Internal";
    import { Pos } from "Iteration/Pos";
    import { IterationOf } from "Iteration/IterationOf";
    import { Extends } from "Any/Extends";
    /**
    Change the format of a **`string`**
    @param S to transform
    @returns **`string | number | boolean`**
    @example
    ```ts
    import {S} from 'ts-toolbelt'
    
    type test0 = S.Format<'30', 'b'> // True
    type test1 = S.Format<'30', 'n'> // 30
    ```
    */
    export type Format<S extends string, fmt extends Formats> = {
        'b': {
            1: Boolean;
            0: S extends 'false' ? 0 : 1;
        }[Extends<string, S>];
        'n': Pos<IterationOf<S>>;
        's': S;
    }[fmt];
}
declare module "Function/Parameters" {
    import { Function } from "Function/Function";
    /**
    Extract parameters from a [[Function]]
    @param F to extract from
    @returns [[List]]
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    const fn = (name: string, age: number) => {}
    
    type test0 = F.ParamsOf<typeof fn>                         // [string, number]
    
    type test1 = F.ParamsOf<(name: string, age: number) => {}> // [string, number]
    ```
    */
    export type Parameters<F extends Function> = F extends ((...args: infer L) => any) ? L : never;
}
declare module "Union/IntersectOf" {
    import { Union } from "Union/Union";
    /**
    Transform a [[Union]] to an **intersection**
    @param U to transform
    @returns **intersection**
    @example
    ```ts
    ```
    */
    export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;
}
declare module "Function/Compose" {
    import { Mode, Input } from "Function/_Internal";
    import { ComposeMultiSync } from "Function/Compose/Multi/Sync";
    import { ComposeMultiAsync } from "Function/Compose/Multi/Async";
    import { ComposeListSync } from "Function/Compose/List/Sync";
    import { ComposeListAsync } from "Function/Compose/List/Async";
    import { Function } from "Function/Function";
    import { Pos } from "Iteration/Pos";
    import { IterationOf } from "Iteration/IterationOf";
    import { Last } from "List/Last";
    import { Format } from "String/Format";
    import { Length } from "List/Length";
    import { Tail } from "List/Tail";
    import { Next } from "Iteration/Next";
    import { Head } from "List/Head";
    import { Return } from "Function/Return";
    import { Parameters } from "Function/Parameters";
    import { PromiseOf } from "Class/PromiseOf";
    import { Or } from "Boolean/Or";
    import { Extends } from "Any/Extends";
    import { List } from "List/List";
    import { IntersectOf } from "Union/IntersectOf";
    /**
    @hidden
    */
    type ComposeFnSync<Fns extends List<Function>, K extends keyof Fns> = Length<Tail<Fns>> extends Format<K & string, 'n'> ? Fns[K] : Function<[// handling unknown generics, waiting for proposal
    Return<Fns[Pos<Next<IterationOf<K & string>>>]> extends infer X ? {
        1: any;
        0: X;
    }[Or<Extends<unknown, X>, Extends<unknown[], X>>] : never], Return<Fns[Pos<IterationOf<K & string>>]>>;
    /**
    @hidden
    */
    type ComposeFnAsync<Fns extends List<Function>, K extends keyof Fns> = Length<Tail<Fns>> extends Format<K & string, 'n'> ? PromiseOf<Fns[K]> : Function<[// handling unknown generics, waiting for proposal
    PromiseOf<Return<Fns[Pos<Next<IterationOf<K & string>>>]>> extends infer X ? {
        1: any;
        0: X;
    }[Or<Extends<unknown, X>, Extends<unknown[], X>>] : never], Return<Fns[Pos<IterationOf<K & string>>]>>;
    /**
    Compute what the input of [[Compose]] should be
    @param Fns to compose
    @param mode (?=`'sync'`) sync/async
    @example
    ```ts
    ```
    */
    export type Composer<Fns extends List<Function>, mode extends Mode = 'sync'> = {
        'sync': {
            [K in keyof Fns]: ComposeFnSync<Fns, K>;
        };
        'async': {
            [K in keyof Fns]: ComposeFnAsync<Fns, K>;
        };
    }[mode];
    /**
    Compose [[Function]]s together
    @param Fns to compose
    @returns [[Function]]
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    /// If you are looking for creating types for `compose`
    /// `Composer` will check for input & `Composed` the output
    declare function compose<Fns extends F.Function[]>(...args: F.Composer<Fns>): F.Composed<Fns>
    
    const a = (a1: number) => `${a1}`
    const c = (c1: string[]) => [c1]
    const b = (b1: string) => [b1]
    
    compose(c, b, a)(42)
    
    /// And if you are looking for an async `compose` type
    declare function compose<Fns extends F.Function[]>(...args: F.Composer<Fns, 'async'>): F.Composed<Fns, 'async'>
    
    const a = async (a1: number) => `${a1}`
    const b = async (b1: string) => [b1]
    const c = async (c1: string[]) => [c1]
    
    await compose(c, b, a)(42)
    */
    export type Composed<Fns extends List<Function>, mode extends Mode = 'sync'> = {
        'sync': (...args: Parameters<Last<Fns>>) => Return<Head<Fns>>;
        'async': (...args: Parameters<Last<Fns>>) => Promise<PromiseOf<Return<Head<Fns>>>>;
    }[mode];
    /**
    Compose [[Function]]s together
    @param mode  (?=`'sync'`)    sync/async (this depends on your implementation)
    @param input (?=`'multi'`)   whether you want it to take a list or parameters
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    /// If you are looking for creating types for `compose`
    /// `Composer` will check for input & `Compose` the output
    declare const compose: F.Compose
    
    const a = (a1: number) => `${a1}`
    const c = (c1: string[]) => [c1]
    const b = (b1: string) => [b1]
    
    compose(c, b, a)(42)
    
    /// And if you are looking for an async `compose` type
    declare const compose: F.Compose<'async'>
    
    const a = async (a1: number) => `${a1}`
    const b = async (b1: string) => [b1]
    const c = async (c1: string[]) => [c1]
    
    await compose(c, b, a)(42)
    */
    export type Compose<mode extends Mode = 'sync', input extends Input = 'multi'> = IntersectOf<{
        'sync': {
            'multi': ComposeMultiSync;
            'list': ComposeListSync;
        };
        'async': {
            'multi': ComposeMultiAsync;
            'list': ComposeListAsync;
        };
    }[mode][input]>;
}
declare module "Iteration/Prev" {
    import { IterationMap } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    /**
    Move **`I`**'s position backwards
    @param I to move
    @returns [[Iteration]]
    @example
    ```ts
    import {I} from 'ts-toolbelt'
    
    type i = I.IterationOf<'20'>
    
    type test0 = I.Pos<i>         // 20
    type test1 = I.Pos<I.Prev<i>> // 19
    ```
    */
    export type Prev<I extends Iteration> = IterationMap[I[0]];
}
declare module "List/Drop" {
    import { Tail } from "List/Tail";
    import { Cast } from "Any/Cast";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    import { Way } from "Iteration/_Internal";
    import { List } from "List/List";
    import { Pos } from "Iteration/Pos";
    import { Prev } from "Iteration/Prev";
    import { Prepend } from "List/Prepend";
    import { Naked } from "List/_Internal";
    import { Extends } from "Any/Extends";
    /**
    @hidden
    */
    type DropForth<L extends List, N extends Iteration> = {
        0: DropForth<Tail<L>, Prev<N>>;
        1: L;
    }[Extends<0, Pos<N>>];
    /**
    @hidden
    */
    type DropBack<L extends List, N extends Iteration, I extends Iteration = Prev<N>, LN extends List = []> = {
        0: DropBack<L, N, Prev<I>, Prepend<LN, L[Pos<I>]>>;
        1: LN;
    }[Extends<-1, Pos<I>>];
    /**
    @hidden
    */
    type __Drop<L extends List, N extends Iteration, way extends Way = '->'> = {
        '->': DropForth<L, N>;
        '<-': DropBack<L, N>;
    }[way];
    /**
    @hidden
    */
    export type _Drop<L extends List, N extends Number, way extends Way = '->'> = __Drop<Naked<L>, IterationOf<N>, way> extends infer X ? Cast<X, List> : never;
    /**
    Remove **`N`** entries out of **`L`**
    @param L to remove from
    @param N to remove out
    @param way (?=`'->'`) to remove from end
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Drop<L extends List, N extends Number, way extends Way = '->'> = L extends unknown ? N extends unknown ? _Drop<L, N, way> : never : never;
}
declare module "Object/_Internal" {
    /**
    Describes the permissions/modifiers fields can have
    * `R`: readonly
    * `W`: writable
    * `!`: required
    * `?`: optional
    */
    export type Modx = ['?' | '!', 'W' | 'R'];
    /**
    Describes the depth strategy when modifying types
    */
    export type Depth = 'flat' | 'deep';
    /**
    Make an object properties (all) `never`. We use this to intersect `object`s and
    preserve the combine modifiers like `readonly` and `?optional`
     */
    export type Empty<O extends object> = {
        [K in keyof O]: undefined;
    };
}
declare module "Object/Merge" {
    import { _Omit } from "Object/Omit";
    import { At } from "Object/At";
    import { Compute } from "Any/Compute";
    import { Depth } from "Object/_Internal";
    import { Kind } from "Any/Kind";
    /**
    @hidden
    */
    export type MergeFlat<O extends object, O1 extends object> = Compute<O & _Omit<O1, keyof O>>;
    /**
    @hidden
    */
    export type MergeDeep<O, O1> = (Kind<(O | O1)> extends 'object' ? MergeFlat<O & {}, O1 & {}> extends infer M ? {
        [K in keyof M]: MergeDeep<M[K], At<O1 & {}, K>>;
    } & {} : never : O);
    /**
    Complete the fields of **`O`** with the ones of **`O1`**
    ('deep' option will skip nullable objects to be merged).
    For more advanced capabilities, see [[MergeUp]].
    @param O to complete
    @param O1 to copy from
    @param depth (?=`'flat'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Merge<O extends object, O1 extends object, depth extends Depth = 'flat'> = {
        'flat': MergeFlat<O, O1>;
        'deep': MergeDeep<O, O1>;
    }[depth];
}
declare module "Union/NonNullable" {
    import { Exclude } from "Union/Exclude";
    import { Union } from "Union/Union";
    /**
    Remove **`undefined`** & **`null`** out of **`U`**
    @param U to make non-nullable
    @returns [[Union]]
    @example
    ```ts
    ```
    */
    export type NonNullable<U extends Union> = Exclude<U, undefined | null>;
}
declare module "Object/NonNullable" {
    import { MergeFlat } from "Object/Merge";
    import { NonNullable as UNonNullable } from "Union/NonNullable";
    import { Depth } from "Object/_Internal";
    import { Pick } from "Object/Pick";
    import { Key } from "Any/Key";
    import { Implements } from "Any/Implements";
    import { Keys } from "Object/Keys";
    /**
    @hidden
    */
    export type NonNullableFlat<O> = {
        [K in keyof O]: UNonNullable<O[K]>;
    } & {};
    /**
    @hidden
    */
    export type NonNullableDeep<O> = {
        [K in keyof O]: NonNullableDeep<UNonNullable<O[K]>>;
    };
    /**
    @hidden
    */
    type NonNullablePart<O extends object, depth extends Depth> = {
        'flat': NonNullableFlat<O>;
        'deep': NonNullableDeep<O>;
    }[depth];
    /**
    Make some fields of **`O`** not nullable (deeply or not)
    (Optional fields will be left untouched & **`undefined`**)
    @param O to make non nullable
    @param K (?=`any`) to choose fields
    @param depth (?=`'flat'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type NonNullable<O extends object, K extends Key = Key, depth extends Depth = 'flat'> = {
        1: NonNullablePart<O, depth>;
        0: MergeFlat<NonNullablePart<Pick<O, K>, depth>, O>;
    }[Implements<Keys<O>, K>] & {};
}
declare module "List/Keys" {
    import { Exclude } from "Union/Exclude";
    import { List } from "List/List";
    import { Keys as UKeys } from "Union/Keys";
    /**
    Get the keys of a [[List]]
    @param L
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type Keys<L extends List> = Exclude<UKeys<L>, keyof any[]> | number;
}
declare module "List/NonNullable" {
    import { Depth } from "Object/_Internal";
    import { NonNullable as ONonNullable } from "Object/NonNullable";
    import { ListOf } from "Object/ListOf";
    import { Cast } from "Any/Cast";
    import { Key } from "Any/Key";
    import { ObjectOf } from "List/ObjectOf";
    import { Implements } from "Any/Implements";
    import { Keys } from "List/Keys";
    import { List } from "List/List";
    import { NumberOf } from "Any/_Internal";
    /**
    Make some entries of **`L`** not nullable (deeply or not)
    @param L to make non nullable
    @param K (?=`any`) to choose fields
    @param depth (?=`'flat'`) to do it deeply
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type NonNullable<L extends List, K extends Key = Key, depth extends Depth = 'flat'> = {
        1: Cast<ONonNullable<L, Key, depth>, List>;
        0: ListOf<ONonNullable<ObjectOf<L>, NumberOf<K>, depth>>;
    }[Implements<Keys<L>, K>] & {};
}
declare module "Function/Curry" {
    import { Pos } from "Iteration/Pos";
    import { _Append } from "List/Append";
    import { _Concat } from "List/Concat";
    import { _Drop } from "List/Drop";
    import { Length } from "List/Length";
    import { Next } from "Iteration/Next";
    import { Cast } from "Any/Cast";
    import { Parameters } from "Function/Parameters";
    import { Return } from "Function/Return";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Key } from "Iteration/Key";
    import { NonNullable } from "List/NonNullable";
    import { x } from "Any/x";
    import { List } from "List/List";
    import { Function } from "Function/Function";
    import { Extends } from "Any/Extends";
    /**
    @hidden
    */
    type GapOf<L1 extends List, L2 extends List, LN extends List, I extends Iteration = IterationOf<'0'>> = L1[Pos<I>] extends x ? _Append<LN, L2[Pos<I>]> : LN;
    /**
    @hidden
    */
    type _GapsOf<L1 extends List, L2 extends List, LN extends List = [], I extends Iteration = IterationOf<'0'>> = {
        0: _GapsOf<L1, L2, GapOf<L1, L2, LN, I>, Next<I>>;
        1: _Concat<LN, _Drop<L2, Key<I>>>;
    }[Extends<Pos<I>, Length<L1>>];
    /**
    @hidden
    */
    type GapsOf<L1 extends List, L2 extends List> = _GapsOf<L1, L2> extends infer X ? Cast<X, List> : never;
    /**
    @hidden
    */
    type Gaps<L extends List> = NonNullable<{
        [K in keyof L]?: L[K] | x;
    }>;
    /**
    Curry a [[Function]]
    @param F to curry
    @returns [[Function]]
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    /// If you are looking for creating types for `curry`
    /// It handles placeholders and variable arguments
    declare function curry<Fn extends F.Function>(fn: Fn): F.Curry<Fn>
    ```
    */
    export type Curry<F extends Function> = <L extends List>(...args: Cast<L, Gaps<Parameters<F>>>) => GapsOf<L, Parameters<F>> extends infer G ? Length<Cast<G, List>> extends infer L ? L extends 0 ? Return<F> : L extends 1 ? Curry<(...args: Cast<G, List>) => Return<F>> & ((...args: Cast<G, List>) => Return<F>) : Curry<(...args: Cast<G, List>) => Return<F>> : never : never;
}
declare module "Function/Length" {
    import { Function } from "Function/Function";
    import { Parameters } from "Function/Parameters";
    import { Formats } from "Iteration/_Internal";
    import { Length as LLength } from "List/Length";
    /**
    Extract arguments' length from a [[Function]]
    @param F to extract from
    @param fmt (?=`'n'`) output
    @returns [[String]] or **`number`**
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    const fn = (a1: any, a2: any) => {}
    
    type test0 = F.LengthOf<typeof fn>               // 2
    
    type test1 = F.LengthOf<(a1?: any) => any>       // 0 | 1
    
    type test2 = F.LengthOf<(...a: any[]) => any>    // number
    ```
    */
    export type Length<Fn extends Function, fmt extends Formats = 'n'> = LLength<Parameters<Fn>, fmt>;
}
declare module "Function/NoInfer" {
    /**
    Explain to TS which function parameter has priority for generic inference
    @param A to de-prioritize
    @returns **`A`**
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    const fn0 = <A extends any>(a0: A, a1: F.NoInfer<A>): A => {
        return {} as unknown as A // just for the example
    }
    
    const fn1 = <A extends any>(a0: F.NoInfer<A>, a1: A): A => {
        return {} as unknown as A // just for the example
    }
    
    const fn2 = <A extends any>(a0: F.NoInfer<A>, a1: F.NoInfer<A>): A => {
        return {} as unknown as A // just for the example
    }
    
    const test0 = fn0('b', 'a') // error: infer priority is `a0`
    const test1 = fn1('b', 'a') // error: infer priority is `a1`
    const test2 = fn2('b', 'a') // works: infer priority is `a0` | `a1`
    ```
    @see https://stackoverflow.com/questions/56687668
    */
    export type NoInfer<A extends any> = [A][A extends any ? 0 : never];
}
declare module "Function/Pipe/Multi/Sync" {
    /** @ignore */ /** */
    import { Function } from "Function/Function";
    import { Head } from "List/Head";
    import { Return } from "Function/Return";
    import { Last } from "List/Last";
    /**
    @hidden
     */
    export type PipeMultiSync = {
        <R0, P extends any[]>(...fns: [Function<P, R0>]): Function<P, R0>;
        <R0, R1, P extends any[]>(...fns: [Function<P, R0>, Function<[R0], R1>]): Function<P, R1>;
        <R0, R1, R2, P extends any[]>(...fns: [Function<P, R0>, Function<[R0], R1>, Function<[R1], R2>]): Function<P, R2>;
        <R0, R1, R2, R3, P extends any[]>(...fns: [Function<P, R0>, Function<[R0], R1>, Function<[R1], R2>, Function<[R2], R3>]): Function<P, R3>;
        <R0, R1, R2, R3, R4, P extends any[]>(...fns: [Function<P, R0>, Function<[R0], R1>, Function<[R1], R2>, Function<[R2], R3>, Function<[R3], R4>]): Function<P, R4>;
        <R0, R1, R2, R3, R4, R5, P extends any[]>(...fns: [Function<P, R0>, Function<[R0], R1>, Function<[R1], R2>, Function<[R2], R3>, Function<[R3], R4>, Function<[R4], R5>]): Function<P, R5>;
        <R0, R1, R2, R3, R4, R5, R6, P extends any[]>(...fns: [Function<P, R0>, Function<[R0], R1>, Function<[R1], R2>, Function<[R2], R3>, Function<[R3], R4>, Function<[R4], R5>, Function<[R5], R6>]): Function<P, R6>;
        <R0, R1, R2, R3, R4, R5, R6, R7, P extends any[]>(...fns: [Function<P, R0>, Function<[R0], R1>, Function<[R1], R2>, Function<[R2], R3>, Function<[R3], R4>, Function<[R4], R5>, Function<[R5], R6>, Function<[R6], R7>]): Function<P, R7>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, P extends any[]>(...fns: [Function<P, R0>, Function<[R0], R1>, Function<[R1], R2>, Function<[R2], R3>, Function<[R3], R4>, Function<[R4], R5>, Function<[R5], R6>, Function<[R6], R7>, Function<[R7], R8>]): Function<P, R8>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, P extends any[]>(...fns: [Function<P, R0>, Function<[R0], R1>, Function<[R1], R2>, Function<[R2], R3>, Function<[R3], R4>, Function<[R4], R5>, Function<[R5], R6>, Function<[R6], R7>, Function<[R7], R8>, Function<[R8], R9>]): Function<P, R9>;
        <Fns extends Function[]>(...fns: Fns): Function<Parameters<Head<Fns>>, Return<Last<Fns>>>;
    };
}
declare module "Function/Pipe/Multi/Async" {
    /** @ignore */ /** */
    import { Function } from "Function/Function";
    import { PromiseOf } from "Class/PromiseOf";
    import { Head } from "List/Head";
    import { Return } from "Function/Return";
    import { Last } from "List/Last";
    /**
    @hidden
     */
    export type PipeMultiAsync = {
        <R0, P extends any[]>(...fns: [Function<P, R0>]): Function<P, Promise<PromiseOf<R0>>>;
        <R0, R1, P extends any[]>(...fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>]): Function<P, Promise<PromiseOf<R1>>>;
        <R0, R1, R2, P extends any[]>(...fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>, Function<[PromiseOf<R1>], R2>]): Function<P, Promise<PromiseOf<R2>>>;
        <R0, R1, R2, R3, P extends any[]>(...fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R2>], R3>]): Function<P, Promise<PromiseOf<R3>>>;
        <R0, R1, R2, R3, R4, P extends any[]>(...fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R3>], R4>]): Function<P, Promise<PromiseOf<R4>>>;
        <R0, R1, R2, R3, R4, R5, P extends any[]>(...fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R4>], R5>]): Function<P, Promise<PromiseOf<R5>>>;
        <R0, R1, R2, R3, R4, R5, R6, P extends any[]>(...fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R5>], R6>]): Function<P, Promise<PromiseOf<R6>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, P extends any[]>(...fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R5>], R6>, Function<[PromiseOf<R6>], R7>]): Function<P, Promise<PromiseOf<R7>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, P extends any[]>(...fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R5>], R6>, Function<[PromiseOf<R6>], R7>, Function<[PromiseOf<R7>], R8>]): Function<P, Promise<PromiseOf<R8>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, P extends any[]>(...fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R5>], R6>, Function<[PromiseOf<R6>], R7>, Function<[PromiseOf<R7>], R8>, Function<[PromiseOf<R8>], R9>]): Function<P, Promise<PromiseOf<R9>>>;
        <Fns extends Function[]>(...fns: Fns): Function<Parameters<Head<Fns>>, Promise<PromiseOf<Return<Last<Fns>>>>>;
    };
}
declare module "Function/Pipe/List/Sync" {
    /** @ignore */ /** */
    import { Function } from "Function/Function";
    import { Head } from "List/Head";
    import { Return } from "Function/Return";
    import { Last } from "List/Last";
    /**
    @hidden
     */
    export type PipeListSync = {
        <R0, P extends any[]>(fns: [Function<P, R0>]): Function<P, R0>;
        <R0, R1, P extends any[]>(fns: [Function<P, R0>, Function<[R0], R1>]): Function<P, R1>;
        <R0, R1, R2, P extends any[]>(fns: [Function<P, R0>, Function<[R0], R1>, Function<[R1], R2>]): Function<P, R2>;
        <R0, R1, R2, R3, P extends any[]>(fns: [Function<P, R0>, Function<[R0], R1>, Function<[R1], R2>, Function<[R2], R3>]): Function<P, R3>;
        <R0, R1, R2, R3, R4, P extends any[]>(fns: [Function<P, R0>, Function<[R0], R1>, Function<[R1], R2>, Function<[R2], R3>, Function<[R3], R4>]): Function<P, R4>;
        <R0, R1, R2, R3, R4, R5, P extends any[]>(fns: [Function<P, R0>, Function<[R0], R1>, Function<[R1], R2>, Function<[R2], R3>, Function<[R3], R4>, Function<[R4], R5>]): Function<P, R5>;
        <R0, R1, R2, R3, R4, R5, R6, P extends any[]>(fns: [Function<P, R0>, Function<[R0], R1>, Function<[R1], R2>, Function<[R2], R3>, Function<[R3], R4>, Function<[R4], R5>, Function<[R5], R6>]): Function<P, R6>;
        <R0, R1, R2, R3, R4, R5, R6, R7, P extends any[]>(fns: [Function<P, R0>, Function<[R0], R1>, Function<[R1], R2>, Function<[R2], R3>, Function<[R3], R4>, Function<[R4], R5>, Function<[R5], R6>, Function<[R6], R7>]): Function<P, R7>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, P extends any[]>(fns: [Function<P, R0>, Function<[R0], R1>, Function<[R1], R2>, Function<[R2], R3>, Function<[R3], R4>, Function<[R4], R5>, Function<[R5], R6>, Function<[R6], R7>, Function<[R7], R8>]): Function<P, R8>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, P extends any[]>(fns: [Function<P, R0>, Function<[R0], R1>, Function<[R1], R2>, Function<[R2], R3>, Function<[R3], R4>, Function<[R4], R5>, Function<[R5], R6>, Function<[R6], R7>, Function<[R7], R8>, Function<[R8], R9>]): Function<P, R9>;
        <Fns extends Function[]>(fns: Fns): Function<Parameters<Head<Fns>>, Return<Last<Fns>>>;
    };
}
declare module "Function/Pipe/List/Async" {
    /** @ignore */ /** */
    import { Function } from "Function/Function";
    import { PromiseOf } from "Class/PromiseOf";
    import { Head } from "List/Head";
    import { Return } from "Function/Return";
    import { Last } from "List/Last";
    /**
    @hidden
     */
    export type PipeListAsync = {
        <R0, P extends any[]>(fns: [Function<P, R0>]): Function<P, Promise<PromiseOf<R0>>>;
        <R0, R1, P extends any[]>(fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>]): Function<P, Promise<PromiseOf<R1>>>;
        <R0, R1, R2, P extends any[]>(fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>, Function<[PromiseOf<R1>], R2>]): Function<P, Promise<PromiseOf<R2>>>;
        <R0, R1, R2, R3, P extends any[]>(fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R2>], R3>]): Function<P, Promise<PromiseOf<R3>>>;
        <R0, R1, R2, R3, R4, P extends any[]>(fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R3>], R4>]): Function<P, Promise<PromiseOf<R4>>>;
        <R0, R1, R2, R3, R4, R5, P extends any[]>(fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R4>], R5>]): Function<P, Promise<PromiseOf<R5>>>;
        <R0, R1, R2, R3, R4, R5, R6, P extends any[]>(fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R5>], R6>]): Function<P, Promise<PromiseOf<R6>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, P extends any[]>(fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R5>], R6>, Function<[PromiseOf<R6>], R7>]): Function<P, Promise<PromiseOf<R7>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, P extends any[]>(fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R5>], R6>, Function<[PromiseOf<R6>], R7>, Function<[PromiseOf<R7>], R8>]): Function<P, Promise<PromiseOf<R8>>>;
        <R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, P extends any[]>(fns: [Function<P, R0>, Function<[PromiseOf<R0>], R1>, Function<[PromiseOf<R1>], R2>, Function<[PromiseOf<R2>], R3>, Function<[PromiseOf<R3>], R4>, Function<[PromiseOf<R4>], R5>, Function<[PromiseOf<R5>], R6>, Function<[PromiseOf<R6>], R7>, Function<[PromiseOf<R7>], R8>, Function<[PromiseOf<R8>], R9>]): Function<P, Promise<PromiseOf<R9>>>;
        <Fns extends Function[]>(fns: Fns): Function<Parameters<Head<Fns>>, Promise<PromiseOf<Return<Last<Fns>>>>>;
    };
}
declare module "Function/Pipe" {
    import { Mode, Input } from "Function/_Internal";
    import { PipeMultiSync } from "Function/Pipe/Multi/Sync";
    import { PipeMultiAsync } from "Function/Pipe/Multi/Async";
    import { PipeListSync } from "Function/Pipe/List/Sync";
    import { PipeListAsync } from "Function/Pipe/List/Async";
    import { Function } from "Function/Function";
    import { Pos } from "Iteration/Pos";
    import { IterationOf } from "Iteration/IterationOf";
    import { Last } from "List/Last";
    import { Prev } from "Iteration/Prev";
    import { Head } from "List/Head";
    import { Return } from "Function/Return";
    import { Parameters } from "Function/Parameters";
    import { PromiseOf } from "Class/PromiseOf";
    import { Or } from "Boolean/Or";
    import { Extends } from "Any/Extends";
    import { List } from "List/List";
    import { IntersectOf } from "Union/IntersectOf";
    /**
    @hidden
    */
    type PipeFnSync<Fns extends List<Function>, K extends keyof Fns> = K extends '0' ? Fns[K] : Function<[// handling unknown generics, waiting for proposal
    Return<Fns[Pos<Prev<IterationOf<K & string>>>]> extends infer X ? {
        1: any;
        0: X;
    }[Or<Extends<unknown, X>, Extends<unknown[], X>>] : never], Return<Fns[Pos<IterationOf<K & string>>]>>;
    /**
    @hidden
    */
    type PipeFnAsync<Fns extends List<Function>, K extends keyof Fns> = K extends '0' ? PromiseOf<Fns[K]> : Function<[// handling unknown generics, waiting for proposal
    PromiseOf<Return<Fns[Pos<Prev<IterationOf<K & string>>>]>> extends infer X ? {
        1: any;
        0: X;
    }[Or<Extends<unknown, X>, Extends<unknown[], X>>] : never], Return<Fns[Pos<IterationOf<K & string>>]>>;
    /**
    Compute what the input of [[Pipe]] should be
    @param Fns to pipe
    @param mode (?=`'sync'`) sync/async
    @example
    ```ts
    ```
    */
    export type Piper<Fns extends List<Function>, mode extends Mode = 'sync'> = {
        'sync': {
            [K in keyof Fns]: PipeFnSync<Fns, K>;
        };
        'async': {
            [K in keyof Fns]: PipeFnAsync<Fns, K>;
        };
    }[mode];
    /**
    Pipe [[Function]]s together
    @param Fns to pipe
    @param mode (?=`'sync'`) sync/async
    @returns [[Function]]
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    /// If you are looking for creating types for `pipe`
    /// `Piper` will check for input & `Piped` the output
    declare function pipe<Fns extends F.Function[]>(...args: F.Piper<Fns>): F.Piped<Fns>
    
    const a = (a1: number) => `${a1}`
    const b = (b1: string) => [b1]
    const c = (c1: string[]) => [c1]
    
    pipe(a, b, c)(42)
    
    /// And if you are looking for an async `pipe` type
    declare function pipe<Fns extends F.Function[]>(...args: F.Piper<Fns, 'async'>): F.Piped<Fns, 'async'>
    
    const a = async (a1: number) => `${a1}`
    const b = async (b1: string) => [b1]
    const c = async (c1: string[]) => [c1]
    
    await pipe(a, b, c)(42)
    ```
    */
    export type Piped<Fns extends List<Function>, mode extends Mode = 'sync'> = {
        'sync': (...args: Parameters<Head<Fns>>) => Return<Last<Fns>>;
        'async': (...args: Parameters<Head<Fns>>) => Promise<PromiseOf<Return<Last<Fns>>>>;
    }[mode];
    /**
    Pipe [[Function]]s together
    @param mode (?=`'sync'`) sync/async (this depends on your implementation)
    @param input (?=`'multi'`) whether you want to take a list or multiple parameters
    @returns [[Function]]
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    /// If you are looking for creating types for `pipe`:
    declare const pipe: F.Pipe
    
    const a = (a1: number) => `${a1}`
    const b = (b1: string) => [b1]
    const c = (c1: string[]) => [c1]
    
    pipe(a, b, c)(42)
    
    /// And if you are looking for an async `pipe` type:
    declare const pipe: F.Pipe<'async'>
    
    const a = async (a1: number) => `${a1}`
    const b = async (b1: string) => [b1]
    const c = async (c1: string[]) => [c1]
    
    await pipe(a, b, c)(42)
    ```
    */
    export type Pipe<mode extends Mode = 'sync', input extends Input = 'multi'> = IntersectOf<{
        'sync': {
            'multi': PipeMultiSync;
            'list': PipeListSync;
        };
        'async': {
            'multi': PipeMultiAsync;
            'list': PipeListAsync;
        };
    }[mode][input]>;
}
declare module "Function/Promisify" {
    import { Function } from "Function/Function";
    import { Parameters } from "Function/Parameters";
    import { Return } from "Function/Return";
    /**
    Creates a promisified version of a **`Function`** **`F`**
    @param F to promisify
    @returns async F
    @example
    ```ts
    import {F} from 'ts-toolbelt'
    
    type test0 = F.Promisify<(a: number) => number> // (a: number) => Promise<number>
    ```
    */
    export type Promisify<F extends Function> = Return<F> extends Promise<any> ? F : (...args: Parameters<F>) => Promise<Return<F>>;
}
declare module "Function/_api" {
    /** @ignore */ /** */
    export { Compose, Composed, Composer } from "Function/Compose";
    export { Curry } from "Function/Curry";
    export { Function } from "Function/Function";
    export { Length } from "Function/Length";
    export { NoInfer } from "Function/NoInfer";
    export { Parameters } from "Function/Parameters";
    export { Pipe, Piped, Piper } from "Function/Pipe";
    export { Promisify } from "Function/Promisify";
    export { Return } from "Function/Return";
}
declare module "Iteration/_api" {
    /** @ignore */ /** */
    export { Format } from "Iteration/Format";
    export { Iteration } from "Iteration/Iteration";
    export { IterationOf } from "Iteration/IterationOf";
    export { Key } from "Iteration/Key";
    export { Next } from "Iteration/Next";
    export { Pos } from "Iteration/Pos";
    export { Prev } from "Iteration/Prev";
}
declare module "Misc/JSON/Primitive" {
    /**
    Basic JSON Value
    */
    export type Primitive = string | number | boolean | null;
}
declare module "Misc/JSON/Object" {
    import { Value } from "Misc/JSON/Value";
    /**
    An object of JSON [[Value]]s
    */
    export interface Object {
        [k: string]: Value;
    }
}
declare module "Misc/JSON/Value" {
    import { Primitive } from "Misc/JSON/Primitive";
    import { List } from "Misc/JSON/Array";
    import { Object } from "Misc/JSON/Object";
    /**
    Any JSON data/value
    */
    export type Value = Primitive | Object | List;
}
declare module "Misc/JSON/Array" {
    import { Value } from "Misc/JSON/Value";
    /**
    A list of JSON [[Value]]s
    */
    export interface List extends Array<Value> {
    }
}
declare module "Misc/JSON/_api" {
    /** @ignore */ /** */
    export { List as Array } from "Misc/JSON/Array";
    export { Object } from "Misc/JSON/Object";
    export { Primitive } from "Misc/JSON/Primitive";
    export { Value } from "Misc/JSON/Value";
}
declare module "Misc/Primitive" {
    export type Primitive = boolean | string | number | bigint | symbol | undefined | null;
}
declare module "Misc/_api" {
    /** @ignore */ /** */
    import * as JSON from "Misc/JSON/_api";
    export { JSON };
    export { Primitive } from "Misc/Primitive";
    export { Promisable } from "Any/Promisable";
}
declare module "Number/IsNegative" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    /**
    @hidden
    */
    export type _IsNegative<N extends Iteration> = {
        '-': 1;
        '+': 0;
        '0': 0;
    }[N[4]];
    /**
    Check whether a [[Number]] is negative or not
    @param N to check
    @returns [[Boolean]]
    @example
    ```ts
    import {N} from 'ts-toolbelt'
    
    type test0 = N.IsNegative<'0'>  // False
    type test1 = N.IsNegative<'-7'> // True
    type test2 = N.IsNegative<'7'>  // False
    ```
    */
    export type IsNegative<N extends Number> = _IsNegative<IterationOf<N>>;
}
declare module "Number/Minus" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Pos } from "Iteration/Pos";
    import { Prev } from "Iteration/Prev";
    import { Next } from "Iteration/Next";
    import { _IsNegative } from "Number/IsNegative";
    import { Cast } from "Any/Cast";
    import { Number } from "Number/Number";
    import { Formats } from "Iteration/_Internal";
    import { Format } from "Iteration/Format";
    /**
    @hidden
    */
    type _MinusPositive<N1 extends Iteration, N2 extends Iteration> = {
        0: _MinusPositive<Prev<N1>, Prev<N2>>;
        1: N1;
        2: N2;
    }[Pos<N2> extends 0 ? 1 : number extends Pos<N2> ? 2 : 0];
    /**
    @hidden
    */
    type MinusPositive<N1 extends Iteration, N2 extends Iteration> = _MinusPositive<N1, N2> extends infer X ? Cast<X, Iteration> : never;
    /**
    @hidden
    */
    type _MinusNegative<N1 extends Iteration, N2 extends Iteration> = {
        0: _MinusNegative<Next<N1>, Next<N2>>;
        1: N1;
        2: N2;
    }[Pos<N2> extends 0 ? 1 : number extends Pos<N2> ? 2 : 0];
    /**
    @hidden
    */
    type MinusNegative<N1 extends Iteration, N2 extends Iteration> = _MinusNegative<N1, N2> extends infer X ? Cast<X, Iteration> : never;
    /**
    @hidden
    */
    export type _Minus<N1 extends Iteration, N2 extends Iteration> = {
        0: MinusPositive<N1, N2>;
        1: MinusNegative<N1, N2>;
    }[_IsNegative<N2>];
    /**
    @hidden
    */
    export type __Minus<N1 extends Number, N2 extends Number, fmt extends Formats = 's'> = Format<_Minus<IterationOf<N1>, IterationOf<N2>>, fmt>;
    /**
    Subtract a [[Number]] from another one
    @param N1 Left-hand side
    @param N2 Right-hand side
    @param fmt (?=`'s'`) output format
    @returns **`string | number | boolean`**
    @example
    ```ts
    import {N} from 'ts-toolbelt'
    
    type test0 = N.Minus<'2', '10'>        // '-8'
    type test1 = N.Minus<'0', '40'>        // '-40'
    type test2 = N.Minus<'0', '40', 's'>   // '-40'
    type test3 = N.Minus<'0', '40', 'n'>   //  -40
    type test4 = N.Minus<'-20', '40', 's'> // string
    type test5 = N.Minus<'-20', '40', 'n'> // number
    ```
    */
    export type Minus<N1 extends Number, N2 extends Number, fmt extends Formats = 's'> = N1 extends unknown ? N2 extends unknown ? __Minus<N1, N2, fmt> : never : never;
}
declare module "Number/Negate" {
    import { _Minus } from "Number/Minus";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    import { Formats } from "Iteration/_Internal";
    import { Format } from "Iteration/Format";
    /**
    @hidden
    */
    export type _Negate<N extends Iteration> = _Minus<IterationOf<'0'>, N>;
    /**
    Negate a [[Number]]
    @param N to negate
    @param fmt (?=`'s'`) output format
    @returns **`string | number | boolean`**
    @example
    ```ts
    import {N} from 'ts-toolbelt'
    
    type test0 = N.Negate<'-10'>     //  '10'
    type test1 = N.Negate<'10'>      // '-10'
    type test2 = N.Negate<'10', 's'> // '-10'
    type test3 = N.Negate<'10', 'n'> //  -10
    type test4 = N.Negate<'-100'>    // string
    ```
    */
    export type Negate<N extends Number, fmt extends Formats = 's'> = Format<_Negate<IterationOf<N>>, fmt>;
}
declare module "Number/Absolute" {
    import { _Negate } from "Number/Negate";
    import { _IsNegative } from "Number/IsNegative";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    import { Formats } from "Iteration/_Internal";
    import { Format } from "Iteration/Format";
    /**
    @hidden
    */
    export type _Absolute<N extends Iteration> = {
        0: N;
        1: _Negate<N>;
    }[_IsNegative<N>];
    /**
    Get the absolute value of a [[Number]]
    @param N to absolute
    @param fmt (?=`'s'`) output format
    @returns **`string | number | boolean`**
    @example
    ```ts
    import {N} from 'ts-toolbelt'
    
    type test0 = N.Absolute<'-20'>      // '20'
    
    type test1 = N.Absolute<'-20', 's'> // '20'
    type test2 = N.Absolute<'-20', 'n'> //  20
    ```
    */
    export type Absolute<N extends Number, fmt extends Formats = 's'> = Format<_Absolute<IterationOf<N>>, fmt>;
}
declare module "Number/IsZero" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    /**
    @hidden
    */
    export type _IsZero<N extends Iteration> = {
        '-': 0;
        '+': 0;
        '0': 1;
    }[N[4]];
    /**
    Check whether a [[Number]] is null or not
    @param N to check
    @returns [[Boolean]]
    @example
    ```ts
    import {N} from 'ts-toolbelt'
    
    type test0 = N.IsZero<'0'>  // True
    type test1 = N.IsZero<'-7'> // False
    type test2 = N.IsZero<'7'>  // False
    ```
    */
    export type IsZero<N extends Number> = _IsZero<IterationOf<N>>;
}
declare module "Number/Format" {
    import { Formats } from "Number/_Internal";
    import { Number } from "Number/Number";
    import { IsZero } from "Number/IsZero";
    import { Not } from "Boolean/Not";
    import { Pos } from "Iteration/Pos";
    import { IterationOf } from "Iteration/IterationOf";
    /**
    Change the format of a [[Number]]
    @param B to transform
    @returns **`string | number | boolean`**
    @example
    ```ts
    import {N} from 'ts-toolbelt'
    
    type test0 = N.Format<'30', 'b'> // True
    type test1 = N.Format<'30', 'n'> // 30
    ```
    */
    export type Format<N extends Number, fmt extends Formats> = {
        'b': Not<IsZero<N>>;
        'n': Pos<IterationOf<N>>;
        's': N;
    }[fmt];
}
declare module "Number/IsPositive" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    /**
    @hidden
    */
    export type _IsPositive<N extends Iteration> = {
        '-': 0;
        '+': 1;
        '0': 0;
    }[N[4]];
    /**
    Check whether a [[Number]] is positive or not
    @param N to check
    @returns [[Boolean]]
    @example
    ```ts
    import {N} from 'ts-toolbelt'
    
    type test0 = N.IsPositive<'0'>  // False
    type test1 = N.IsPositive<'-7'> // False
    type test2 = N.IsPositive<'7'>  // True
    ```
    */
    export type IsPositive<N extends Number> = _IsPositive<IterationOf<N>>;
}
declare module "Number/Greater" {
    import { _Minus } from "Number/Minus";
    import { _IsPositive } from "Number/IsPositive";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    /**
    @hidden
    */
    export type _Greater<N1 extends Iteration, N2 extends Iteration> = _IsPositive<_Minus<N1, N2>>;
    /**
    Check if a [[Number]] is bigger than another one
    @param N1 to compare
    @param N2 to compare to
    @returns [[Boolean]]
    @example
    ```ts
    import {N} from 'ts-toolbelt'
    
    type test0 = N.Greater<'7', '5'> // True
    type test1 = N.Greater<'5', '5'> // False
    type test2 = N.Greater<'5', '7'> // False
    ```
    */
    export type Greater<N1 extends Number, N2 extends Number> = _Greater<IterationOf<N1>, IterationOf<N2>>;
}
declare module "Number/GreaterEq" {
    import { Equals } from "Any/Equals";
    import { _Greater } from "Number/Greater";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    import { Or } from "Boolean/Or";
    /**
    @hidden
    */
    export type _GreaterEq<N1 extends Iteration, N2 extends Iteration> = Or<Equals<N1, N2>, _Greater<N1, N2>>;
    /**
    Check if a [[Number]] is greater or equal to another one
    @param N1 to compare
    @param N2 to compare to
    @returns [[Boolean]]
    @example
    ```ts
    import {N} from 'ts-toolbelt'
    
    type test0 = N.GreaterEq<'7', '5'> // True
    type test1 = N.GreaterEq<'5', '5'> // True
    type test2 = N.GreaterEq<'5', '7'> // False
    ```
    */
    export type GreaterEq<N1 extends Number, N2 extends Number> = _GreaterEq<IterationOf<N1>, IterationOf<N2>>;
}
declare module "Number/Lower" {
    import { _Greater } from "Number/Greater";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    /**
    @hidden
    */
    export type _Lower<N1 extends Iteration, N2 extends Iteration> = _Greater<N2, N1>;
    /**
    Check if a [[Number]] is lower than another one
    @param N1 to compare
    @param N2 to compare to
    @returns [[Boolean]]
    @example
    ```ts
    import {N} from 'ts-toolbelt'
    
    type test0 = N.Lower<'7', '5'> // False
    type test1 = N.Lower<'5', '5'> // False
    type test2 = N.Lower<'5', '7'> // True
    ```
    */
    export type Lower<N1 extends Number, N2 extends Number> = _Lower<IterationOf<N1>, IterationOf<N2>>;
}
declare module "Number/LowerEq" {
    import { GreaterEq } from "Number/GreaterEq";
    import { Number } from "Number/Number";
    /**
    Check if a [[Number]] is lower or equal to another one
    @param N1 to compare
    @param N2 to compare to
    @returns [[Boolean]]
    @example
    ```ts
    import {N} from 'ts-toolbelt'
    
    type test0 = N.LowerEq<'7', '5'> // False
    type test1 = N.LowerEq<'5', '5'> // True
    type test2 = N.LowerEq<'5', '7'> // True
    ```
    */
    export type LowerEq<N1 extends Number, N2 extends Number> = GreaterEq<N2, N1>;
}
declare module "Number/Max" {
    import { Prev } from "Iteration/Prev";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Next } from "Iteration/Next";
    import { Numbers } from "Number/_Internal";
    import { Number } from "Number/Number";
    import { Formats } from "Iteration/_Internal";
    import { Key } from "Iteration/Key";
    import { _IsNegative } from "Number/IsNegative";
    import { Exclude } from "Union/Exclude";
    import { Cast } from "Any/Cast";
    import { Format } from "Iteration/Format";
    import { Extends } from "Any/Extends";
    import { Or } from "Boolean/Or";
    /**
    @hidden
    */
    type _MaxPositive<N extends Number, I extends Iteration = IterationOf<'0'>> = {
        0: _MaxPositive<Exclude<N, Key<I>>, Next<I>>;
        1: Prev<I>;
        2: string;
    }[[N] extends [never] ? 1 : string extends N ? 2 : 0];
    /**
    @hidden
    */
    type MaxPositive<N extends Number> = _MaxPositive<N> extends infer X ? Cast<X, Iteration> : never;
    /**
    @hidden
    */
    type _MaxNegative<N extends Number, I extends Iteration = IterationOf<'0'>> = {
        0: _MaxNegative<Exclude<N, Key<I>>, Prev<I>>;
        1: I;
    }[Or<Extends<Key<I>, N>, Extends<string, Key<I>>>];
    /**
    @hidden
    */
    type MaxNegative<N extends Number> = _MaxNegative<N> extends infer X ? Cast<X, Iteration> : never;
    /**
    @hidden
    */
    export type _Max<N extends Iteration> = _IsNegative<N> extends 1 ? MaxNegative<Key<N>> : MaxPositive<Exclude<Key<N>, Numbers['string']['-']>>;
    /**
    Get the biggest [[Number]] within an [[Union]]
    @param N [[Union]]
    @param fmt (?=`'s'`) output format
    @returns **`string | number | boolean`**
    @example
    ```ts
    import {N} from 'ts-toolbelt'
    
    type test0 = N.Max<'-2' | '10' | '3'>      // '10'
    type test1 = N.Max<'-2' | '10' | '3', 's'> // '10'
    type test2 = N.Max<'-2' | '10' | '3', 'n'> //  10
    type test3 = N.Min<'-2' | '10' | 'oops'>   // string
    ```
    */
    export type Max<N extends Number, fmt extends Formats = 's'> = Format<_Max<IterationOf<N>>, fmt>;
}
declare module "Number/Min" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Next } from "Iteration/Next";
    import { Numbers } from "Number/_Internal";
    import { Number } from "Number/Number";
    import { Formats } from "Iteration/_Internal";
    import { Cast } from "Any/Cast";
    import { Key } from "Iteration/Key";
    import { Prev } from "Iteration/Prev";
    import { _IsPositive } from "Number/IsPositive";
    import { Exclude } from "Union/Exclude";
    import { Format } from "Iteration/Format";
    import { Or } from "Boolean/Or";
    import { Extends } from "Any/Extends";
    /**
    @hidden
    */
    type _MinPositive<N extends Number, I extends Iteration = IterationOf<'0'>> = {
        0: _MinPositive<N, Next<I>>;
        1: I;
    }[Or<Extends<Key<I>, N>, Extends<string, Key<I>>>];
    /**
    @hidden
    */
    type MinPositive<N extends Number> = _MinPositive<N> extends infer X ? Cast<X, Iteration> : never;
    /**
    @hidden
    */
    type _MinNegative<N extends Number, I extends Iteration = IterationOf<'0'>> = {
        0: _MinNegative<Exclude<N, Key<I>>, Prev<I>>;
        1: Next<I>;
        2: string;
    }[[N] extends [never] ? 1 : string extends N ? 2 : 0];
    /**
    @hidden
    */
    type MinNegative<N extends Number> = _MinNegative<N> extends infer X ? Cast<X, Iteration> : never;
    /**
    @hidden
    */
    export type _Min<N extends Iteration> = _IsPositive<N> extends 1 ? MinPositive<Key<N>> : MinNegative<Exclude<Key<N>, Numbers['string']['+']>>;
    /**
    Get the smallest [[Number]] within an [[Union]]
    @param N [[Union]]
    @param fmt (?=`'s'`) output format
    @returns **`string | number | boolean`**
    @example
    ```ts
    import {N} from 'ts-toolbelt'
    
    type test0 = N.Min<'-2' | '10' | '3'>      // '-2'
    type test1 = N.Min<'-2' | '10' | '3', 's'> // '-2'
    type test2 = N.Min<'-2' | '10' | '3', 'n'> //  -2
    type test3 = N.Min<'-2' | '10' | 'oops'>   // string
    ```
    */
    export type Min<N extends Number, fmt extends Formats = 's'> = Format<_Min<IterationOf<N>>, fmt>;
}
declare module "Number/Plus" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Pos } from "Iteration/Pos";
    import { Prev } from "Iteration/Prev";
    import { Next } from "Iteration/Next";
    import { _IsNegative } from "Number/IsNegative";
    import { Cast } from "Any/Cast";
    import { Number } from "Number/Number";
    import { Formats } from "Iteration/_Internal";
    import { Format } from "Iteration/Format";
    /**
    @hidden
    */
    type _PlusPositive<N1 extends Iteration, N2 extends Iteration> = {
        0: _PlusPositive<Next<N1>, Prev<N2>>;
        1: N1;
        2: number;
    }[Pos<N2> extends 0 ? 1 : number extends Pos<N2> ? 2 : 0];
    /**
    @hidden
    */
    type PlusPositive<N1 extends Iteration, N2 extends Iteration> = _PlusPositive<N1, N2> extends infer X ? Cast<X, Iteration> : never;
    /**
    @hidden
    */
    type _PlusNegative<N1 extends Iteration, N2 extends Iteration> = {
        0: _PlusNegative<Prev<N1>, Next<N2>>;
        1: N1;
        2: number;
    }[Pos<N2> extends 0 ? 1 : number extends Pos<N2> ? 2 : 0];
    /**
    @hidden
    */
    type PlusNegative<N1 extends Iteration, N2 extends Iteration> = _PlusNegative<N1, N2> extends infer X ? Cast<X, Iteration> : never;
    /**
    @hidden
    */
    export type _Plus<N1 extends Iteration, N2 extends Iteration> = {
        0: PlusPositive<N1, N2>;
        1: PlusNegative<N1, N2>;
    }[_IsNegative<N2>];
    /**
    @hidden
    */
    export type __Plus<N1 extends Number, N2 extends Number, fmt extends Formats = 's'> = Format<_Plus<IterationOf<N1>, IterationOf<N2>>, fmt>;
    /**
    Add a [[Number]] to another one
    @param N1 Left-hand side
    @param N2 Right-hand side
    @param fmt (?=`'s'`) output format
    @returns **`string | number | boolean`**
    @example
    ```ts
    import {N} from 'ts-toolbelt'
    
    type test0 = N.Plus<'2', '10'>        // '12'
    type test1 = N.Plus<'0', '40'>        // '40'
    type test2 = N.Plus<'0', '40', 's'>   // '40'
    type test3 = N.Plus<'0', '40', 'n'>   //  40
    type test4 = N.Plus<'-20', '40', 's'> // '20'
    type test5 = N.Plus<'-20', '40', 'n'> //  20
    ```
    */
    export type Plus<N1 extends Number, N2 extends Number, fmt extends Formats = 's'> = N1 extends unknown ? N2 extends unknown ? __Plus<N1, N2, fmt> : never : never;
}
declare module "Number/Range" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Prepend } from "List/Prepend";
    import { Prev } from "Iteration/Prev";
    import { Next } from "Iteration/Next";
    import { Number } from "Number/Number";
    import { Cast } from "Any/Cast";
    import { Formats } from "Iteration/_Internal";
    import { Way } from "Iteration/_Internal";
    import { Format } from "Iteration/Format";
    import { List } from "List/List";
    import { Extends } from "Any/Extends";
    /**
    @hidden
    */
    type RangeForth<From extends Iteration, To extends Iteration, fmt extends Formats = 's', L extends List = []> = {
        0: RangeForth<Prev<From>, To, fmt, Prepend<L, Format<From, fmt>>>;
        1: L;
    }[Extends<From, To>];
    /**
    @hidden
    */
    type RangeBack<From extends Iteration, To extends Iteration, fmt extends Formats = 's', L extends List = []> = {
        0: RangeBack<Next<From>, To, fmt, Prepend<L, Format<From, fmt>>>;
        1: L;
    }[Extends<From, To>];
    /**
    @hidden
    */
    type __Range<From extends Iteration, To extends Iteration, way extends Way, fmt extends Formats> = {
        '->': RangeForth<To, Prev<From>, fmt>;
        '<-': RangeBack<From, Next<To>, fmt>;
    }[way];
    /**
    @hidden
    */
    export type _Range<From extends Number, To extends Number, way extends Way = '->', fmt extends Formats = 's'> = __Range<IterationOf<From>, IterationOf<To>, way, fmt> extends infer X ? Cast<X, (string | number)[]> : never;
    /**
    Create a range of **number**s
    @param From to start with
    @param To to end with
    @param way (?=`'->'`) to reverse it
    @param fmt (?=`'s'`) output format
    @returns **`string[] | number[] | boolean[]`**
    @example
    ```ts
    import {N} from 'ts-toolbelt'
    
    type test0 = N.Range<'-2', '1'>            // ['-2', '-1', '0', '1']
    type test1 = N.Range<'-2', '1', '->'>      // ['-2', '-1', '0', '1']
    type test2 = N.Range<'-2', '1', '<-'>      // ['1', '0', '-1', '-2']
    type test3 = N.Range<'-2', '1', '<-', 's'> // ['1', '0', '-1', '-2']
    type test4 = N.Range<'-2', '1', '->', 'n'> // [-2 , -1 ,   0 ,   1 ]
    ```
    */
    export type Range<From extends Number, To extends Number, way extends Way = '->', fmt extends Formats = 's'> = From extends unknown ? To extends unknown ? _Range<From, To, way, fmt> : never : never;
}
declare module "Number/_api" {
    /** @ignore */ /** */
    export { Absolute } from "Number/Absolute";
    export { Format } from "Number/Format";
    export { Greater } from "Number/Greater";
    export { GreaterEq } from "Number/GreaterEq";
    export { IsNegative } from "Number/IsNegative";
    export { IsPositive } from "Number/IsPositive";
    export { IsZero } from "Number/IsZero";
    export { Lower } from "Number/Lower";
    export { LowerEq } from "Number/LowerEq";
    export { Max } from "Number/Max";
    export { Min } from "Number/Min";
    export { Minus } from "Number/Minus";
    export { Negate } from "Number/Negate";
    export { NumberOf } from "Number/NumberOf";
    export { Plus } from "Number/Plus";
    export { Range } from "Number/Range";
}
declare module "Object/P/Merge" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Key } from "Any/Key";
    import { Merge as OMerge } from "Object/Merge";
    import { Length } from "List/Length";
    import { List } from "List/List";
    import { Depth } from "Object/_Internal";
    import { Boolean } from "Boolean/Boolean";
    /**
    @hidden
    */
    type MergeObject<O, Path extends List<Key>, O1 extends object, depth extends Depth, I extends Iteration = IterationOf<'0'>> = O extends object ? Pos<I> extends Length<Path> ? OMerge<O, O1, depth> : {
        [K in keyof O]: K extends Path[Pos<I>] ? MergeObject<O[K], Path, O1, depth, Next<I>> : O[K];
    } & {} : O;
    /**
    @hidden
    */
    type MergeList<O, Path extends List<Key>, O1 extends object, depth extends Depth, I extends Iteration = IterationOf<'0'>> = O extends object ? O extends (infer A)[] ? {
        1: MergeList<A, Path, O1, depth, I>[];
        0: never;
    }[O extends List ? 1 : 0] : Pos<I> extends Length<Path> ? OMerge<O, O1, depth> : {
        [K in keyof O]: K extends Path[Pos<I>] ? MergeList<O[K], Path, O1, depth, Next<I>> : O[K];
    } & {} : O;
    /**
    Complete the fields of **`O`** at **`Path`** with the ones of **`O1`**
    @param O to complete
    @param Path to be followed
    @param O1 to copy from
    @param depth (?=`'flat'`) to do it deeply
    @param list (?=`0`) `1` to work within object lists
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Merge<O extends object, Path extends List<Key>, O1 extends object, depth extends Depth = 'flat', list extends Boolean = 0> = {
        0: MergeObject<O, Path, O1, depth>;
        1: MergeList<O, Path, O1, depth>;
    }[list];
}
declare module "List/LastIndex" {
    import { Length } from "List/Length";
    import { Formats } from "Iteration/_Internal";
    import { Tail } from "List/Tail";
    import { List } from "List/List";
    /**
    Get the last index of **`L`**
    @param L to get from
    @param fmt (?=`'n'`) output format
    @returns [[String]] or **`number`**
    @example
    ```ts
    ```
    */
    export type LastIndex<L extends List, fmt extends Formats = 'n'> = Length<Tail<L>, fmt>;
}
declare module "Object/P/Omit" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Key } from "Any/Key";
    import { _Omit as _OOmit } from "Object/Omit";
    import { LastIndex } from "List/LastIndex";
    import { List } from "List/List";
    import { Boolean } from "Boolean/Boolean";
    /**
    @hidden
    */
    type OmitObject<O, Path extends List<Key>, I extends Iteration = IterationOf<'0'>> = O extends object ? Pos<I> extends LastIndex<Path> ? _OOmit<O, Path[Pos<I>]> : {
        [K in keyof O]: K extends Path[Pos<I>] ? OmitObject<O[K], Path, Next<I>> : O[K];
    } & {} : O;
    /**
    @hidden
    */
    type OmitList<O, Path extends List<Key>, I extends Iteration = IterationOf<'0'>> = O extends object ? O extends (infer A)[] ? {
        1: OmitList<A, Path, I>[];
        0: never;
    }[O extends List ? 1 : 0] : Pos<I> extends LastIndex<Path> ? _OOmit<O, Path[Pos<I>]> : {
        [K in keyof O]: K extends Path[Pos<I>] ? OmitList<O[K], Path, Next<I>> : O[K];
    } & {} : O;
    /**
    Remove out of **`O`** the fields at **`Path`**
    @param O to remove from
    @param Path to be followed
    @param list (?=`0`) `1` to work within object lists
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Omit<O extends object, Path extends List<Key>, list extends Boolean = 0> = {
        0: OmitObject<O, Path>;
        1: OmitList<O, Path>;
    }[list];
}
declare module "Object/P/Pick" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Key } from "Any/Key";
    import { _Pick as _OPick } from "Object/Pick";
    import { LastIndex } from "List/LastIndex";
    import { List } from "List/List";
    import { Boolean } from "Boolean/Boolean";
    /**
    @hidden
    */
    type PickObject<O, Path extends List<Key>, I extends Iteration = IterationOf<'0'>> = O extends object ? _OPick<O, Path[Pos<I>]> extends infer Picked ? Pos<I> extends LastIndex<Path> ? Picked : {
        [K in keyof Picked]: PickObject<Picked[K], Path, Next<I>>;
    } & {} : never : O;
    /**
    @hidden
    */
    type PickList<O, Path extends List<Key>, I extends Iteration = IterationOf<'0'>> = O extends object ? O extends (infer A)[] ? {
        1: PickList<A, Path, I>[];
        0: never;
    }[O extends List ? 1 : 0] : _OPick<O, Path[Pos<I>]> extends infer Picked ? Pos<I> extends LastIndex<Path> ? Picked : {
        [K in keyof Picked]: PickList<Picked[K], Path, Next<I>>;
    } & {} : never : O;
    /**
    Extract out of **`O`** the fields at **`Path`**
    @param O to extract from
    @param Path to be followed
    @param list (?=`0`) `1` to work within object lists
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Pick<O extends object, Path extends List<Key>, list extends Boolean = 0> = {
        0: PickObject<O, Path>;
        1: PickList<O, Path>;
    }[list];
}
declare module "Object/Readonly" {
    import { MergeFlat } from "Object/Merge";
    import { Pick } from "Object/Pick";
    import { Depth } from "Object/_Internal";
    import { Key } from "Any/Key";
    import { Implements } from "Any/Implements";
    import { Keys } from "Union/Keys";
    /**
    @hidden
    */
    export type ReadonlyFlat<O> = {
        +readonly [K in keyof O]: O[K];
    } & {};
    /**
    @hidden
    */
    export type ReadonlyDeep<O> = {
        +readonly [K in keyof O]: ReadonlyDeep<O[K]>;
    };
    /**
    @hidden
    */
    type ReadonlyPart<O extends object, depth extends Depth> = {
        'flat': ReadonlyFlat<O>;
        'deep': ReadonlyDeep<O>;
    }[depth];
    /**
    Make some fields of **`O`** readonly (deeply or not)
    @param O to make readonly
    @param K (?=`any`) to choose fields
    @param depth (?=`'default'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Readonly<O extends object, K extends Key = Key, depth extends Depth = 'flat'> = {
        1: ReadonlyPart<O, depth>;
        0: MergeFlat<ReadonlyPart<Pick<O, K>, depth>, O>;
    }[Implements<Keys<O>, K>] & {};
}
declare module "Object/P/Readonly" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Key } from "Any/Key";
    import { Readonly as OReadonly } from "Object/Readonly";
    import { LastIndex } from "List/LastIndex";
    import { List } from "List/List";
    import { Depth } from "Object/_Internal";
    import { Boolean } from "Boolean/Boolean";
    /**
    @hidden
    */
    type ReadonlyObject<O, Path extends List<Key>, depth extends Depth, I extends Iteration = IterationOf<'0'>> = O extends object ? Pos<I> extends LastIndex<Path> ? OReadonly<O, Path[Pos<I>], depth> : {
        [K in keyof O]: K extends Path[Pos<I>] ? ReadonlyObject<O[K], Path, depth, Next<I>> : O[K];
    } & {} : O;
    /**
    @hidden
    */
    type ReadonlyArrays<O, Path extends List<Key>, depth extends Depth, I extends Iteration = IterationOf<'0'>> = O extends object ? O extends (infer A)[] ? {
        1: ReadonlyArrays<A, Path, depth, I>[];
        0: never;
    }[O extends List ? 1 : 0] : Pos<I> extends LastIndex<Path> ? OReadonly<O, Path[Pos<I>], depth> : {
        [K in keyof O]: K extends Path[Pos<I>] ? ReadonlyArrays<O[K], Path, depth, Next<I>> : O[K];
    } & {} : O;
    /**
    Make some fields of **`O`** readonly at **`Path`** (deeply or not)
    @param O to make readonly
    @param Path to be followed
    @param depth (?=`'flat'`) to do it deeply
    @param list (?=`0`) `1` to work within object lists
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Readonly<O extends object, Path extends List<Key>, depth extends Depth = 'flat', list extends Boolean = 0> = {
        0: ReadonlyObject<O, Path, depth>;
        1: ReadonlyArrays<O, Path, depth>;
    }[list];
}
declare module "Union/Replace" {
    import { Union } from "Union/Union";
    /**
    Replace **`M`** with **`A`** in **`U`**
    @param U to update
    @param M to select
    @param A to update with
    @returns [[Union]]
    @example
    ```ts
    ```
    */
    export type Replace<U extends Union, M extends any, A extends any> = U extends M ? A : U;
}
declare module "Object/Update" {
    import { Key } from "Any/Key";
    import { x } from "Any/x";
    import { Replace } from "Union/Replace";
    import { MergeFlat } from "Object/Merge";
    import { Exclude } from "Union/Exclude";
    import { Keys } from "Object/Keys";
    /**
    Update in **`O`** the fields of key **`K`** with **`A`**.
    Use the [[x]] placeholder to get the current field type.
    @param O to update
    @param K to chose fields
    @param A to update with
    @returns [[Object]]
    @example
    ```ts
    import {A, O} from 'ts-toolbelt'
    
    type User = {
        info: {
            name: string
            age: number
            payment: {}
        }
        id: number
    }
    
    type test0 = Update<User, 'id' | 'info', A.x | null>
    // {
    //     info: {
    //         name: string;
    //         age: number;
    //         payment: {};
    //     } | null;
    //     id: number | null;
    // }
    ```
    */
    export type Update<O extends object, K extends Key, A extends any> = MergeFlat<{
        [P in keyof O]: P extends K ? Replace<A, x, O[P]> : O[P];
    } & {}, Record<Exclude<K, Keys<O>>, Exclude<A, x>>>;
}
declare module "Object/P/Record" {
    import { Modx } from "Object/_Internal";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Key } from "Any/Key";
    import { LastIndex } from "List/LastIndex";
    import { List } from "List/List";
    /**
    @hidden
    */
    type _Record_RR<Path extends List<Key>, A, I extends Iteration = IterationOf<'0'>> = {
        readonly [Key in Path[Pos<I>]]: Pos<I> extends LastIndex<Path> ? A : _Record_RR<Path, A, Next<I>>;
    } & {};
    /**
    @hidden
    */
    export type _Record_RW<Path extends List<Key>, A, I extends Iteration = IterationOf<'0'>> = {
        [Key in Path[Pos<I>]]: Pos<I> extends LastIndex<Path> ? A : _Record_RW<Path, A, Next<I>>;
    } & {};
    /**
    @hidden
    */
    type _Record_OR<Path extends List<Key>, A, I extends Iteration = IterationOf<'0'>> = {
        readonly [Key in Path[Pos<I>]]?: Pos<I> extends LastIndex<Path> ? A : _Record_OR<Path, A, Next<I>>;
    } & {};
    /**
    @hidden
    */
    type _Record_OW<Path extends List<Key>, A, I extends Iteration = IterationOf<'0'>> = {
        [Key in Path[Pos<I>]]?: Pos<I> extends LastIndex<Path> ? A : _Record_OW<Path, A, Next<I>>;
    } & {};
    /**
    Create an object filled with **`A`** for the fields at the end of **`Path`**
    @param Path to choose fields
    @param A to fill fields with
    @param modx (?=`['!', 'W']`) to set modifiers
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Record<Path extends List<Key>, A, modx extends Modx = ['!', 'W']> = {
        '!': {
            'R': _Record_RR<Path, A>;
            'W': _Record_RW<Path, A>;
        };
        '?': {
            'R': _Record_OR<Path, A>;
            'W': _Record_OW<Path, A>;
        };
    }[modx[0]][modx[1]];
}
declare module "Object/Record" {
    import { Modx } from "Object/_Internal";
    import { Key } from "Any/Key";
    /**
    Create an object filled with **`A`** for the fields **`K`**
    @param K to choose fields
    @param A to fill fields with
    @param modx (?=`['!', 'W']`) to set modifiers
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Record<K extends Key, A extends any, modx extends Modx = ['!', 'W']> = {
        '!': {
            'R': {
                readonly [P in K]: A;
            };
            'W': {
                [P in K]: A;
            };
        };
        '?': {
            'R': {
                readonly [P in K]?: A;
            };
            'W': {
                [P in K]?: A;
            };
        };
    }[modx[0]][modx[1]];
}
declare module "Object/P/Update" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Key } from "Any/Key";
    import { Update as OUpdate } from "Object/Update";
    import { LastIndex } from "List/LastIndex";
    import { List } from "List/List";
    import { Record } from "Object/Record";
    /**
    @hidden
    */
    type _Update<O, Path extends List<Key>, A, I extends Iteration = IterationOf<'0'>> = O extends object ? Pos<I> extends LastIndex<Path> ? OUpdate<O, Path[Pos<I>], A> : (O & Record<Exclude<Path[Pos<I>], keyof O>, {}>) extends infer O ? {
        [K in keyof O]: K extends Path[Pos<I>] ? _Update<O[K], Path, A, Next<I>> : O[K];
    } & {} : never : O;
    /**
    Update in **`O`** the fields at **`Path`** with **`A`**
    (⚠️ this type is expensive)
    @param O to update
    @param Path to be followed
    @param A to update with
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Update<O extends object, Path extends List<Key>, A extends any> = _Update<O, Path, A>;
}
declare module "Object/P/_api" {
    /** @ignore */ /** */
    export { Merge } from "Object/P/Merge";
    export { Omit } from "Object/P/Omit";
    export { Pick } from "Object/P/Pick";
    export { Readonly } from "Object/P/Readonly";
    export { Update } from "Object/P/Update";
    export { Record } from "Object/P/Record";
}
declare module "Object/Assign" {
    import { Iteration } from "Iteration/Iteration";
    import { IterationOf } from "Iteration/IterationOf";
    import { Merge } from "Object/Merge";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Length } from "List/Length";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    import { Extends } from "Any/Extends";
    import { Depth } from "Object/_Internal";
    /**
    @hidden
    */
    type __Assign<O extends object, Os extends List<object>, depth extends Depth, I extends Iteration = IterationOf<'0'>> = {
        0: __Assign<Merge<Os[Pos<I>], O, depth>, Os, depth, Next<I>>;
        1: O;
    }[Extends<Pos<I>, Length<Os>>];
    /**
    @hidden
    */
    export type _Assign<O extends object, Os extends List<object>, depth extends Depth> = __Assign<O, Os, depth> extends infer X ? Cast<X, object> : never;
    /**
    Assign a list of [[Object]] into **`O`** with [[Merge]] (last-in overrides)
    @param O to assign to
    @param Os to assign
    @param depth (?=`'flat'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Assign<O extends object, Os extends List<object>, depth extends Depth = 'flat'> = O extends unknown ? Os extends unknown ? _Assign<O, Os, depth> : never : never;
}
declare module "Object/OptionalKeys" {
    import { Key } from "Any/Key";
    /**
    @hidden
    */
    export type _OptionalKeys<O extends object> = {
        [K in keyof O]-?: {} extends Pick<O, K> ? K : never;
    }[keyof O];
    /**
    Get the keys of **`O`** that are optional
    @param O
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type OptionalKeys<O extends object> = (O extends unknown ? _OptionalKeys<O> : never) & Key;
}
declare module "Union/Select" {
    import { Union } from "Union/Union";
    /**
    Extract the part of **`U`** that matches **`M`**
    @param U to extract from
    @param M to select with
    @returns [[Union]]
    @example
    ```ts
    ```
    */
    export type Select<U extends Union, M extends any> = U extends M ? U : never;
}
declare module "Object/MergeUp" {
    import { At } from "Object/At";
    import { Depth, Empty } from "Object/_Internal";
    import { Kind } from "Any/Kind";
    import { OptionalKeys } from "Object/OptionalKeys";
    import { Key } from "Any/Key";
    import { NonNullable } from "Union/NonNullable";
    import { And } from "Boolean/And";
    import { Extends } from "Any/Extends";
    import { Boolean } from "Boolean/Boolean";
    import { Or } from "Boolean/Or";
    import { Select } from "Union/Select";
    /**
    @hidden
    */
    type MergeUpProp<O extends object, O1 extends object, K extends Key, IsOptional extends Boolean> = IsOptional extends 1 ? NonNullable<At<O, K>> | At<O1, K> : [At<O, K>] extends [never] ? At<O1, K> : At<O, K>;
    /**
    @hidden
    */
    export type _MergeUpFlat<O extends object, O1 extends object, OOK extends Key = OptionalKeys<O>> = {
        [K in keyof (Empty<O> & Empty<O1>)]: MergeUpProp<O, O1, K, Extends<K, OOK>>;
    } & {};
    /**
    @hidden
    */
    type MergeUpFlat<O extends object, O1 extends object> = O extends unknown ? O1 extends unknown ? _MergeUpFlat<O, O1> : never : never;
    /**
    @hidden
    */
    export type _MergeUpDeep<O extends object, O1 extends object, IsParentOptional extends Boolean = 0, OOK extends keyof O = OptionalKeys<O>> = {
        [K in keyof (Empty<O> & Empty<O1>)]: And<// we first make sure that both are objects
        Extends<Kind<NonNullable<At<O, K>>>, 'object'>, Extends<Kind<NonNullable<At<O1, K>>>, 'object'>> extends 1 ? MergeUpDeep<// if it is the case, recurse deeper
        // if it is the case, recurse deeper
        At<O, K> & {}, // merge O[K]
        // merge O[K]
        At<O1, K> & {}, // with O1[K]
        K extends OOK ? 1 : 0> | (Extends<K, OOK> extends 0 ? Select<At<O, K>, undefined | null> : never) : MergeUpProp<// otherwise, we treat them as fields
        O, O1, K, Or<// if parent, or the field `K` are optional
        IsParentOptional, Extends<K, OOK>>>;
    };
    /**
    @hidden
    */
    type MergeUpDeep<O extends object, O1 extends object, IsParentOptional extends Boolean = 0> = O extends unknown ? O1 extends unknown ? _MergeUpDeep<O, O1, IsParentOptional> : never : never;
    /**
    Accurately complete the fields of **`O`** with the ones of **`O1`**.
    This is a version of `Merge` that handles optional fields. It understands
    that merged optional fields are no longer optional (have been completed).
    And it is able to deal with the merging of **`Union`s** of [[Object]]s.
    @param O to complete
    @param O1 to copy from
    @param depth (?=`'flat'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    import {O} from 'ts-toolbelt'
    
    type O = {
        name?: string
        age? : number
        zip? : string
        pay  : {
            cvv?: number
        }
    }
    
    type O1 = {
        age : number
        zip?: number
        city: string
        pay : {
            cvv : number
            ccn?: string
        }
    }
    
    type test = O.MergeUp<O, O1, 'deep'>
    // {
    //     name?: string | undefined;
    //     age: number;
    //     zip?: string | number;
    //     pay: {
    //         cvv: number;
    //         ccn?: string | undefined;
    //     };
    //     city: string;
    // }
    ```
    */
    export type MergeUp<O extends object, O1 extends object, depth extends Depth = 'flat'> = {
        'flat': MergeUpFlat<O, O1>;
        'deep': MergeUpDeep<O, O1>;
    }[depth];
}
declare module "Object/AssignUp" {
    import { Iteration } from "Iteration/Iteration";
    import { IterationOf } from "Iteration/IterationOf";
    import { MergeUp } from "Object/MergeUp";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Length } from "List/Length";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    import { Extends } from "Any/Extends";
    import { Depth } from "Object/_Internal";
    /**
    @hidden
    */
    type __AssignUp<O extends object, Os extends List<object>, depth extends Depth, I extends Iteration = IterationOf<'0'>> = {
        0: __AssignUp<MergeUp<Os[Pos<I>], O, depth>, Os, depth, Next<I>>;
        1: O;
    }[Extends<Pos<I>, Length<Os>>];
    /**
    @hidden
    */
    export type _AssignUp<O extends object, Os extends List<object>, depth extends Depth> = __AssignUp<O, Os, depth> extends infer X ? Cast<X, object> : never;
    /**
    Assign a list of [[Object]] into **`O`** with [[MergeUp]] (last-in combines or overrides)
    @param O to assign to
    @param Os to assign
    @param depth (?=`'flat'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type AssignUp<O extends object, Os extends List<object>, depth extends Depth = 'flat'> = O extends unknown ? Os extends unknown ? _AssignUp<O, Os, depth> : never : never;
}
declare module "Object/Compact" {
    import { Iteration } from "Iteration/Iteration";
    import { IterationOf } from "Iteration/IterationOf";
    import { Merge } from "Object/Merge";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Length } from "List/Length";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    import { Extends } from "Any/Extends";
    import { Depth } from "Object/_Internal";
    /**
    @hidden
    */
    type __Compact<O extends object, Os extends List<object>, depth extends Depth, I extends Iteration = IterationOf<'0'>> = {
        0: __Compact<Merge<O, Os[Pos<I>], depth>, Os, depth, Next<I>>;
        1: O;
    }[Extends<Pos<I>, Length<Os>>];
    /**
    @hidden
    */
    export type _Compact<O extends object, Os extends List<object>, depth extends Depth> = __Compact<O, Os, depth> extends infer X ? Cast<X, object> : never;
    /**
    Merge a list of [[Object]] into **`O`** with [[Merge]] (last-in completes)
    @param O to assign to
    @param Os to assign
    @param depth (?=`'flat'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Compact<O extends object, Os extends List<object>, depth extends Depth = 'flat'> = O extends unknown ? Os extends unknown ? _Compact<O, Os, depth> : never : never;
}
declare module "Object/CompactUp" {
    import { Iteration } from "Iteration/Iteration";
    import { IterationOf } from "Iteration/IterationOf";
    import { MergeUp } from "Object/MergeUp";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Length } from "List/Length";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    import { Extends } from "Any/Extends";
    import { Depth } from "Object/_Internal";
    /**
    @hidden
    */
    type __CompactUp<O extends object, Os extends List<object>, depth extends Depth, I extends Iteration = IterationOf<'0'>> = {
        0: __CompactUp<MergeUp<O, Os[Pos<I>], depth>, Os, depth, Next<I>>;
        1: O;
    }[Extends<Pos<I>, Length<Os>>];
    /**
    @hidden
    */
    export type _AssignUp<O extends object, Os extends List<object>, depth extends Depth> = __CompactUp<O, Os, depth> extends infer X ? Cast<X, object> : never;
    /**
    Merge a list of [[Object]] into **`O`** with [[MergeUp]] (last-in combines or completes)
    @param O to assign to
    @param Os to assign
    @param depth (?=`'flat'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type CompactUp<O extends object, Os extends List<object>, depth extends Depth = 'flat'> = O extends unknown ? Os extends unknown ? _AssignUp<O, Os, depth> : never : never;
}
declare module "Object/Compulsory" {
    import { MergeFlat } from "Object/Merge";
    import { Pick } from "Object/Pick";
    import { Depth } from "Object/_Internal";
    import { Key } from "Any/Key";
    import { Implements } from "Any/Implements";
    import { NonNullable } from "Union/NonNullable";
    import { Keys } from "Object/Keys";
    /**
    @hidden
    */
    export type CompulsoryFlat<O> = {
        [K in keyof O]-?: NonNullable<O[K]>;
    } & {};
    /**
    @hidden
    */
    export type CompulsoryDeep<O> = {
        [K in keyof O]-?: CompulsoryDeep<NonNullable<O[K]>>;
    };
    /**
    @hidden
    */
    type CompulsoryPart<O extends object, depth extends Depth> = {
        'flat': CompulsoryFlat<O>;
        'deep': CompulsoryDeep<O>;
    }[depth];
    /**
    Make some fields of **`O`** compulsory (deeply or not)
    (it's like [[Required]] & [[NonNullable]] at once).
    @param O to make compulsory
    @param K (?=`any`) to choose fields
    @param depth (?=`'flat'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Compulsory<O extends object, K extends Key = Key, depth extends Depth = 'flat'> = {
        1: CompulsoryPart<O, depth>;
        0: MergeFlat<CompulsoryPart<Pick<O, K>, depth>, O>;
    }[Implements<Keys<O>, K>] & {};
}
declare module "Object/CompulsoryKeys" {
    import { Key } from "Any/Key";
    /**
    @hidden
    */
    export type _CompulsoryKeys<O extends object> = {
        [K in keyof O]: [O[K] & (undefined | null)] extends [never] ? K : never;
    }[keyof O];
    /**
    Get the keys of **`O`** that are compulsory
    (⚠️ needs `--strictNullChecks` enabled)
    @param O
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type CompulsoryKeys<O extends object> = (O extends unknown ? _CompulsoryKeys<O> : never) & Key;
}
declare module "Object/ExcludeKeys" {
    import { Exclude } from "Union/Exclude";
    import { Match } from "Any/_Internal";
    import { Is } from "Any/Is";
    import { At } from "Object/At";
    import { Keys } from "Object/Keys";
    import { Key } from "Any/Key";
    /**
    @hidden
    */
    export type _ExcludeMatch<O extends object, O1 extends object, match extends Match> = {
        [K in keyof O]: {
            1: never;
            0: K;
        }[Is<O[K], At<O1, K>, match>];
    }[keyof O];
    /**
    @hidden
    */
    type ExcludeMatch<O extends object, O1 extends object, match extends Match> = (O extends unknown ? _ExcludeMatch<O, O1, match> : never) & Key;
    /**
    Exclude the keys of **`O1`** out of the keys of **`O`**
    (If `match = 'default'`, no type checks are done)
    @param O to remove the keys from
    @param O1 to remove the keys out
    @param match (?=`'default'`) to change precision
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type ExcludeKeys<O extends object, O1 extends object, match extends Match = 'default'> = {
        'default': Exclude<Keys<O>, Keys<O1>>;
        'implements->': ExcludeMatch<O, O1, 'implements->'>;
        'extends->': ExcludeMatch<O, O1, 'extends->'>;
        '<-implements': ExcludeMatch<O, O1, '<-implements'>;
        '<-extends': ExcludeMatch<O, O1, '<-extends'>;
        'equals': ExcludeMatch<O, O1, 'equals'>;
    }[match];
}
declare module "Object/Exclude" {
    import { ExcludeKeys } from "Object/ExcludeKeys";
    import { Match } from "Any/_Internal";
    import { Pick } from "Object/Pick";
    /**
    Exclude the fields of **`O1`** out of **`O`**
    (If `match = 'default'`, no type checks are done)
    @param O to remove from
    @param O1 to remove out
    @param match (?=`'default'`) to change precision
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Exclude<O extends object, O1 extends object, match extends Match = 'default'> = Pick<O, ExcludeKeys<O, O1, match>>;
}
declare module "Object/Diff" {
    import { MergeFlat } from "Object/Merge";
    import { Exclude } from "Object/Exclude";
    import { Match } from "Any/_Internal";
    /**
    Get an [[Object]] that is the difference between **`O`** & **`O1`**
    (**`O`**'s differences have priority over **`O1`**'s if fields overlap)
    (If `match = 'default'`, no type checks are done)
    @param O to check differences with
    @param O1 to check differences against
    @param match (?=`'default'`) to change precision
    @returns [[Object]]
    @example
    ```ts
    import {O} from 'ts-toolbelt'
    
    type Person0 = {
        name: string
        age: string
    }
    
    type Person1 = {
        name: string
        age: number | string
        nick: string
    }
    
    type test0 = O.Diff<Person0, Person1, 'default'>   // {nick: string}
    type test1 = O.Diff<Person0, Person1, 'extends->'> // {nick: string; age: string | number}
    type test2 = O.Diff<Person0, Person1, '<-extends'> // {nick: string; age: string}
    type test3 = O.Diff<Person0, Person1, 'equals'>    // {nick: string; age: string}
    ```
    */
    export type Diff<O extends object, O1 extends object, match extends Match = 'default'> = MergeFlat<Exclude<O, O1, match>, Exclude<O1, O, match>>;
}
declare module "Object/Optional" {
    import { MergeFlat } from "Object/Merge";
    import { Pick } from "Object/Pick";
    import { Depth } from "Object/_Internal";
    import { Key } from "Any/Key";
    import { Implements } from "Any/Implements";
    import { Keys } from "Object/Keys";
    /**
    @hidden
    */
    export type OptionalFlat<O> = {
        [K in keyof O]?: O[K];
    } & {};
    /**
    @hidden
    */
    export type OptionalDeep<O> = {
        [K in keyof O]?: OptionalDeep<O[K]>;
    };
    /**
    @hidden
    */
    type OptionalPart<O extends object, depth extends Depth> = {
        'flat': OptionalFlat<O>;
        'deep': OptionalDeep<O>;
    }[depth];
    /**
    Make some fields of **`O`** optional (deeply or not)
    @param O to make optional
    @param K (?=`any`) to choose fields
    @param depth (?=`'default'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Optional<O extends object, K extends Key = Key, depth extends Depth = 'flat'> = {
        1: OptionalPart<O, depth>;
        0: MergeFlat<OptionalPart<Pick<O, K>, depth>, O>;
    }[Implements<Keys<O>, K>] & {};
}
declare module "Union/Strict" {
    import { Compute } from "Any/Compute";
    import { Keys } from "Union/Keys";
    import { OptionalFlat } from "Object/Optional";
    import { Record } from "Object/Record";
    /**
    @hidden
    */
    type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<Record<Exclude<Keys<_U>, keyof U>, never>> : never;
    /**
    Make a [[Union]] not allow excess properties (https://github.com/Microsoft/TypeScript/issues/20863)
    @param U to make strict
    @returns [[Union]]
    @example
    ```ts
    ```
    */
    export type Strict<U extends object> = Compute<_Strict<U>>;
}
declare module "Object/Either" {
    import { _Omit } from "Object/Omit";
    import { _Pick } from "Object/Pick";
    import { Key } from "Any/Key";
    import { Strict } from "Union/Strict";
    import { Boolean } from "Boolean/Boolean";
    import { Compute } from "Any/Compute";
    /**
    @hidden
    */
    type __Either<O extends object, K extends Key> = _Omit<O, K> & ({
        [P in K]: _Pick<O, P>;
    }[K]);
    /**
    @hidden
    */
    type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;
    /**
    @hidden
    */
    type EitherLoose<O extends object, K extends Key> = Compute<__Either<O, K>>;
    /**
    @hidden
    */
    export type _Either<O extends object, K extends Key, strict extends Boolean> = {
        1: EitherStrict<O, K>;
        0: EitherLoose<O, K>;
    }[strict];
    /**
    Split **`O`** into a [[Union]] with **`K`** keys in such a way that none of
    the keys are ever present with one another within the different unions.
    @param O to split
    @param K to split with
    @param strict (?=`1`) to force excess property checks https://github.com/microsoft/TypeScript/issues/20863
    @returns [[Object]] [[Union]]
    @example
    ```ts
    ```
    */
    export type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown ? _Either<O, K, strict> : never;
}
declare module "Object/FilterKeys" {
    import { Match } from "Any/_Internal";
    import { Is } from "Any/Is";
    import { Key } from "Any/Key";
    /**
    @hidden
    */
    export type _FilterKeys<O extends object, M extends any, match extends Match = 'default'> = {
        [K in keyof O]: {
            1: never;
            0: K;
        }[Is<O[K], M, match>];
    }[keyof O];
    /**
    Filter out the keys of **`O`** which fields match **`M`**
    @param O to remove from
    @param M to select fields
    @param match (?=`'default'`) to change precision
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type FilterKeys<O extends object, M extends any, match extends Match = 'default'> = (O extends unknown ? _FilterKeys<O, M, match> : never) & Key;
}
declare module "Object/Filter" {
    import { FilterKeys } from "Object/FilterKeys";
    import { Match } from "Any/_Internal";
    import { Pick } from "Object/Pick";
    /**
    Filter out of **`O`** the fields that match **`M`**
    @param O to remove from
    @param M to select fields
    @param match (?=`'default'`) to change precision
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Filter<O extends object, M extends any, match extends Match = 'default'> = Pick<O, FilterKeys<O, M, match>>;
}
declare module "Object/Has" {
    import { Match } from "Any/_Internal";
    import { Is } from "Any/Is";
    import { At } from "Object/At";
    import { Key } from "Any/Key";
    /**
    Check whether **`O`** has a field of key **`K`** that matches **`M`**
    @param O to be inspected
    @param K to choose field
    @param M (?=`any`) to check field type
    @param match (?=`'default'`) to change precision
    @returns [[Boolean]]
    @example
    ```ts
    ```
    */
    export type Has<O extends object, K extends Key, M extends any = any, match extends Match = 'default'> = Is<At<O, K>, M, match>;
}
declare module "Object/Path" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Next } from "Iteration/Next";
    import { Pos } from "Iteration/Pos";
    import { Length } from "List/Length";
    import { At } from "Object/At";
    import { Cast } from "Any/Cast";
    import { NonNullable } from "Union/NonNullable";
    import { Key } from "Any/Key";
    import { List } from "List/List";
    import { Boolean } from "Boolean/Boolean";
    import { Extends } from "Any/Extends";
    /**
    @hidden
    */
    type __Path<O, Path extends List<Key>, strict extends Boolean, OPrev = O, I extends Iteration = IterationOf<'0'>> = {
        0: __Path<At<NonNullable<O> & {}, Path[Pos<I>], strict>, Path, strict, O, Next<I>>;
        1: O;
    }[Extends<Pos<I>, Length<Path>>];
    /**
    @hidden
    */
    export type _Path<O extends object, Path extends List<Key>, strict extends Boolean = 1> = __Path<O, Path, strict> extends infer X ? Cast<X, any> : never;
    /**
    Get in **`O`** the type of nested properties
    For more advanced capabilities, see [[PathUp]]
    @param O to be inspected
    @param Path to be followed
    @param strict (?=`1`) `0` to work with unions
    @returns **`any`**
    @example
    ```ts
    ```
    */
    export type Path<O extends object, Path extends List<Key>, strict extends Boolean = 1> = Path extends unknown ? _Path<O, Path, strict> : never;
}
declare module "Object/HasPath" {
    import { Match } from "Any/_Internal";
    import { Path as OPath } from "Object/Path";
    import { Is } from "Any/Is";
    import { Key } from "Any/Key";
    import { List } from "List/List";
    /**
    Check whether **`O`** has nested properties that match **`M`**
    @param O to be inspected
    @param Path to be followed
    @param M (?=`any`) to check field type
    @param match (?=`'default'`) to change precision
    @returns [[Boolean]]
    @example
    ```ts
    ```
    */
    export type HasPath<O extends object, Path extends List<Key>, M extends any = any, match extends Match = 'default'> = Is<OPath<O, Path>, M, match>;
}
declare module "Object/SelectKeys" {
    import { Match } from "Any/_Internal";
    import { Is } from "Any/Is";
    import { Key } from "Any/Key";
    /**
    @hidden
    */
    export type _SelectKeys<O extends object, M extends any, match extends Match = 'default'> = {
        [K in keyof O]: {
            1: K;
            0: never;
        }[Is<O[K], M, match>];
    }[keyof O];
    /**
    Get the keys of **`O`** which fields match **`M`**
    @param O to extract from
    @param M to select fields
    @param match (?=`'default'`) to change precision
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type SelectKeys<O extends object, M extends any, match extends Match = 'default'> = (O extends unknown ? _SelectKeys<O, M, match> : never) & Key;
}
declare module "Object/Includes" {
    import { SelectKeys } from "Object/SelectKeys";
    import { Match } from "Any/_Internal";
    /**
    Check whether **`O`** has fields that match **`M`**
    @param O to be inspected
    @param M to check field type
    @param match (?=`'default'`) to change precision
    @returns [[Boolean]]
    @example
    ```ts
    ```
    */
    export type Includes<O extends object, M extends any, match extends Match = 'default'> = [SelectKeys<O, M, match>] extends [never] ? 0 : 1;
}
declare module "Union/Intersect" {
    import { Union } from "Union/Union";
    /**
    Get the intersection of **`U1`** & **`U2`**
    @param U1 to check similarities with
    @param U2 to check similarities against
    @returns [[Union]]
    @example
    ```ts
    ```
    */
    export type Intersect<U1 extends Union, U2 extends Union> = U1 & U2;
}
declare module "Object/IntersectKeys" {
    import { Intersect } from "Union/Intersect";
    import { Match } from "Any/_Internal";
    import { Is } from "Any/Is";
    import { At } from "Object/At";
    import { Keys } from "Object/Keys";
    import { Key } from "Any/Key";
    /**
    @hidden
    */
    export type _IntersectMatch<O extends object, O1 extends object, match extends Match> = {
        [K in keyof O]: {
            1: K;
            0: never;
        }[Is<O[K], At<O1, K>, match>];
    }[keyof O];
    /**
    @hidden
    */
    type IntersectMatch<O extends object, O1 extends object, match extends Match> = (O extends unknown ? _IntersectMatch<O, O1, match> : never) & Key;
    /**
    Get the intersecting keys of **`O`** & **`O1`**
    (If `match = 'default'`, no type checks are done)
    @param O to check similarities with
    @param O1 to check similarities against
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type IntersectKeys<O extends object, O1 extends object, match extends Match = 'default'> = {
        'default': Intersect<Keys<O>, Keys<O1>>;
        'implements->': IntersectMatch<O, O1, 'implements->'>;
        'extends->': IntersectMatch<O, O1, 'extends->'>;
        '<-implements': IntersectMatch<O, O1, '<-implements'>;
        '<-extends': IntersectMatch<O, O1, '<-extends'>;
        'equals': IntersectMatch<O, O1, 'equals'>;
    }[match];
}
declare module "Object/Intersect" {
    import { IntersectKeys } from "Object/IntersectKeys";
    import { Match } from "Any/_Internal";
    import { Pick } from "Object/Pick";
    /**
    Get the intersecting fields of **`O`** & **`O1`**
    (If `match = 'default'`, no type checks are done)
    @param O to check similarities with
    @param O1 to check similarities against
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Intersect<O extends object, O1 extends object, match extends Match = 'default'> = Pick<O, IntersectKeys<O, O1, match>>;
}
declare module "Object/Invert" {
    import { Record } from "Object/Record";
    import { Key } from "Any/Key";
    import { IntersectOf } from "Union/IntersectOf";
    import { Compute } from "Any/Compute";
    /**
    @hidden
    */
    export type _Invert<O extends Record<Key, Key>> = Compute<IntersectOf<{
        [K in keyof O]: Record<O[K], K>;
    }[keyof O]>>;
    /**
    Swaps the keys and values of an [[Object]] (if applicable)
    @param O
    @returns [[Object]]
    @example
    ```ts
    import {O} from 'ts-toolbelt'
    
    enum E {
        A = 'Av',
        B = 'Bv',
        C = 'Cv',
        D = 'Dv',
        X = 1
    }
    
    type O = {
        A: 'Av'
        B: 'Bv'
        C: 'Cv'
        D: 'Dv'
        X: 1
    }
    
    type test0 = O.Invert<typeof E>
    type test1 = O.Invert<O>
    ```
    */
    export type Invert<O extends Record<Key, Key>> = O extends unknown ? _Invert<O> : never;
}
declare module "Object/Modify" {
    import { At } from "Object/At";
    import { Replace } from "Union/Replace";
    import { x } from "Any/x";
    import { Exclude } from "Union/Exclude";
    /**
    Modify **`O`** with **`OMod`** & the [[x]] placeholder
    @param O to copy from
    @param OMod to copy to
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Modify<O extends object, OMod extends object> = {
        [K in keyof OMod]: Replace<OMod[K], x, Exclude<At<O, K>, undefined>>;
    } & {};
}
declare module "Object/NonNullableKeys" {
    import { Key } from "Any/Key";
    /**
    @hidden
    */
    export type _NonNullableKeys<O extends object> = {
        [K in keyof O]: [O[K] & (undefined | null)] extends [never] ? K : never;
    }[keyof O];
    /**
    Get the keys of **`O`** that are non-nullable
    (⚠️ needs `--strictNullChecks` enabled)
    @param O
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type NonNullableKeys<O extends object> = (O extends unknown ? _NonNullableKeys<O> : never) & Key;
}
declare module "Union/Nullable" {
    import { Union } from "Union/Union";
    /**
    Add **`undefined`** to **`U`**
    @param U to make nullable
    @returns [[Union]]
    @example
    ```ts
    ```
    */
    export type Nullable<U extends Union> = U | undefined;
}
declare module "Object/Nullable" {
    import { MergeFlat } from "Object/Merge";
    import { Nullable as UNullable } from "Union/Nullable";
    import { Depth } from "Object/_Internal";
    import { Pick } from "Object/Pick";
    import { Key } from "Any/Key";
    import { Implements } from "Any/Implements";
    import { Keys } from "Object/Keys";
    /**
    @hidden
    */
    export type NullableFlat<O> = {
        [K in keyof O]: UNullable<O[K]>;
    } & {};
    /**
    @hidden
    */
    export type NullableDeep<O> = {
        [K in keyof O]: NullableDeep<UNullable<O[K]>>;
    };
    /**
    @hidden
    */
    type NullablePart<O extends object, depth extends Depth> = {
        'flat': NullableFlat<O>;
        'deep': NullableDeep<O>;
    }[depth];
    /**
    Make some fields of **`O`** nullable (deeply or not)
    @param O to make nullable
    @param K (?=`any`) to choose fields
    @param depth (?=`'flat'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Nullable<O extends object, K extends Key = Key, depth extends Depth = 'flat'> = {
        1: NullablePart<O, depth>;
        0: MergeFlat<NullablePart<Pick<O, K>, depth>, O>;
    }[Implements<Keys<O>, K>] & {};
}
declare module "Object/NullableKeys" {
    import { Key } from "Any/Key";
    /**
    @hidden
    */
    export type _NullableKeys<O extends object> = {
        [K in keyof O]: [O[K] & (undefined | null)] extends [never] ? never : K;
    }[keyof O];
    /**
    Get the keys of **`O`** that are nullable
    (⚠️ needs `--strictNullChecks` enabled)
    @param O
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type NullableKeys<O extends object> = (O extends unknown ? _NullableKeys<O> : never) & Key;
}
declare module "Object/Object" {
    /**
    An [[Object]]
    @example
    ```ts
    type object0 = {a: "hello"}
    type string1 = {b: "world"}
    ```
    */
    export type Object = object;
}
declare module "Object/Paths" {
    import { OptionalFlat } from "Object/Optional";
    import { Key } from "Any/Key";
    import { NonNullableFlat } from "Object/NonNullable";
    import { _Concat } from "List/Concat";
    import { Cast } from "Any/Cast";
    import { Equals } from "Any/Equals";
    import { List } from "List/List";
    import { _Append } from "List/Append";
    /**
    @hidden
    */
    type __Paths<O, Paths extends List<Key> = []> = {
        0: {
            [K in keyof O]: __Paths<O[K], _Append<Paths, K>>;
        }[keyof O];
        1: NonNullableFlat<OptionalFlat<Paths>>;
        2: NonNullableFlat<OptionalFlat<_Concat<Paths, Key[]>>>;
    }[Equals<O, any> extends 1 ? 2 : O extends object ? [keyof O] extends [never] ? 1 : 0 : 1];
    /**
    @hidden
    */
    export type _Paths<O extends object> = __Paths<O> extends infer X ? Cast<X, List<Key>> : never;
    /**
    Get all the possible paths of **`O`**
    (⚠️ this won't work with circular-refs)
    @param O to be inspected
    @returns **`string[]`**
    @example
    ```ts
    ```
    */
    export type Paths<O extends object> = O extends unknown ? _Paths<O> : never;
}
declare module "List/Overwrite" {
    import { Overwrite as OOverwrite } from "Object/Overwrite";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    /**
    Update the entries of **`L`** with the ones of **`L1`**
    @param L to update
    @param L1 to update with
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Overwrite<L extends List, L1 extends object> = Cast<OOverwrite<L, L1>, List>;
}
declare module "List/Update" {
    import { Key as IKey } from "Iteration/Key";
    import { IterationOf } from "Iteration/IterationOf";
    import { Key } from "Any/Key";
    import { List } from "List/List";
    import { Replace } from "Union/Replace";
    import { x } from "Any/x";
    import { GreaterEq } from "Number/GreaterEq";
    import { Length } from "List/Length";
    import { Overwrite } from "List/Overwrite";
    import { _Repeat } from "List/Repeat";
    import { Next } from "Iteration/Next";
    import { Naked } from "List/_Internal";
    import { NumberOf } from "Any/_Internal";
    import { Extends } from "Any/Extends";
    import { Or } from "Boolean/Or";
    /**
    @hidden
    */
    export type UpdateField<L extends List, K extends string, A extends any> = {
        [P in keyof L]: P extends K ? Replace<A, x, L[P]> : L[P];
    } & {};
    /**
    @hidden
    */
    type UpdateTuple<L extends List, K extends string, A extends any> = GreaterEq<K, Length<L, 's'>> extends 1 ? UpdateField<Overwrite<_Repeat<undefined, IKey<Next<IterationOf<K>>>>, L>, K, A> : UpdateField<L, K, A>;
    /**
    @hidden
    */
    type UpdateList<L extends List, A extends any> = (L[number] | A)[];
    /**
    @hidden
    */
    export type _Update<L extends List, K extends Key, A extends any> = Or<Extends<number, Length<L>>, Extends<number, K>> extends 1 ? UpdateList<L, A> : UpdateTuple<Naked<L>, NumberOf<K> & string, A>;
    /**
    Update in **`L`** the entries of key **`K`** with **`A`**.
    Use the [[x]] placeholder to get the current field type.
    @param L to update
    @param K to chose fields
    @param A to update with
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Update<L extends List, K extends Key, A extends any> = L extends unknown ? K extends unknown ? _Update<L, K, A> : never : never;
}
declare module "Object/PathValid" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Next } from "Iteration/Next";
    import { Pos } from "Iteration/Pos";
    import { At } from "Object/At";
    import { Cast } from "Any/Cast";
    import { NonNullable as UNonNullable } from "Union/NonNullable";
    import { UpdateField } from "List/Update";
    import { Key } from "Iteration/Key";
    import { Key as AKey } from "Any/Key";
    import { List } from "List/List";
    import { Length } from "List/Length";
    /**
    @hidden
    */
    type ValidatePath<O, Path extends List<AKey>, I extends Iteration> = UpdateField<Path, Key<I>, [At<O & {}, Path[Pos<I>]>] extends [never] ? never : Path[Pos<I>]>;
    /**
    @hidden
    */
    type __PathValid<O, Path extends List<AKey>, I extends Iteration = IterationOf<'0'>> = {
        0: __PathValid<UNonNullable<At<O & {}, Path[Pos<I>]>>, ValidatePath<O, Path, I>, Next<I>>;
        1: Path;
    }[Pos<I> extends Length<Path> ? 1 : 0];
    /**
    @hidden
    */
    export type _PathValid<O extends object, Path extends List<AKey>> = __PathValid<O, Path> extends infer X ? Cast<X, List<AKey>> : never;
    /**
     * Replaces invalid parts of a path with `never`
     * @param O to be inspected
     * @param Path to be validated
     * @returns **`Index[]`**
     * @example
     * ```ts
     * import {A, L, O} from 'ts-toolbelt'
     *
     * // Get a property in an object `o` at any depth with `path`
     * // `A.Cast<P, O.PathValid<O, P>>` makes sure `path` is valid
     * const getAt = <
     * O extends object,
     * P extends L.List<A.Index>
     * >(o: O, path: A.Cast<P, O.PathValid<O, P>>): O.Path<O, P> => {
     *     let valueAt = o
     *
     *     for (const p of path)
     *         valueAt = valueAt[p]
     *
     *     return valueAt as any
     * }
     *
     * const test0 = getAt({a: {b: {c: 1}}},          ['a', 'b'] as const) // {c: number}
     * const test1 = getAt({a: {b: {c: 1}}} as const, ['a', 'b'] as const) // {c: 1}
     * const test2 = getAt({a: {b: {c: 1}}},          ['x'] as const)      // error
     * ```
     */
    export type PathValid<O extends object, Path extends List<AKey>> = O extends unknown ? Path extends unknown ? _PathValid<O, Path> : never : never;
}
declare module "Object/ReadonlyKeys" {
    import { Equals } from "Any/Equals";
    import { Key } from "Any/Key";
    /**
    @hidden
    */
    export type _ReadonlyKeys<O extends object> = {
        [K in keyof O]-?: {
            1: never;
            0: K;
        }[Equals<{
            -readonly [Q in K]: O[K];
        }, {
            [Q in K]: O[K];
        }>];
    }[keyof O];
    /**
    Get the keys of **`O`** that are readonly
    @param O
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type ReadonlyKeys<O extends object> = (O extends unknown ? _ReadonlyKeys<O> : never) & Key;
}
declare module "Object/Replace" {
    import { Match } from "Any/_Internal";
    import { Is } from "Any/Is";
    /**
    @hidden
    */
    export type _Replace<O extends object, M extends any, A extends any, match extends Match = 'default'> = {
        [K in keyof O]: {
            1: A;
            0: O[K];
        }[Is<M, O[K], match>];
    } & {};
    /**
    Update with **`A`** the fields of **`O`** that match **`M`**
    @param O to update
    @param M to select fields
    @param A to update with
    @param match (?=`'default'`) to change precision
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Replace<O extends object, M extends any, A extends any, match extends Match = 'default'> = O extends unknown ? _Replace<O, M, A, match> : never;
}
declare module "Object/Required" {
    import { MergeFlat } from "Object/Merge";
    import { Pick } from "Object/Pick";
    import { Depth } from "Object/_Internal";
    import { Key } from "Any/Key";
    import { Implements } from "Any/Implements";
    import { Keys } from "Object/Keys";
    /**
    @hidden
    */
    export type RequiredFlat<O> = {
        [K in keyof O]-?: O[K];
    } & {};
    /**
    @hidden
    */
    export type RequiredDeep<O> = {
        [K in keyof O]-?: RequiredDeep<O[K]>;
    };
    /**
    @hidden
    */
    type RequiredPart<O extends object, depth extends Depth> = {
        'flat': RequiredFlat<O>;
        'deep': RequiredDeep<O>;
    }[depth];
    /**
    Make some fields of **`O`** required (deeply or not)
    @param O to make required
    @param K (?=`any`) to choose fields
    @param depth (?=`'flat'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Required<O extends object, K extends Key = Key, depth extends Depth = 'flat'> = {
        1: RequiredPart<O, depth>;
        0: MergeFlat<RequiredPart<Pick<O, K>, depth>, O>;
    }[Implements<Keys<O>, K>] & {};
}
declare module "Object/RequiredKeys" {
    import { Key } from "Any/Key";
    /**
    @hidden
    */
    export type _RequiredKeys<O extends object> = {
        [K in keyof O]-?: {} extends Pick<O, K> ? never : K;
    }[keyof O];
    /**
    Get the keys of **`O`** that are required
    @param O
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type RequiredKeys<O extends object> = (O extends unknown ? _RequiredKeys<O> : never) & Key;
}
declare module "Object/Select" {
    import { SelectKeys } from "Object/SelectKeys";
    import { Match } from "Any/_Internal";
    import { Pick } from "Object/Pick";
    /**
    Extract the fields of **`O`** that match **`M`**
    @param O to extract from
    @param M to select fields
    @param match (?=`'default'`) to change precision
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Select<O extends object, M extends any, match extends Match = 'default'> = Pick<O, SelectKeys<O, M, match>>;
}
declare module "Object/Unionize" {
    import { At } from "Object/At";
    import { Key } from "Any/Key";
    /**
    Make the fields of **`O`** union the ones of **`O1`**
    @param O to union from
    @param O1 to union with
    @param K (?=`any`) to chose fields
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Unionize<O extends object, O1 extends object, K extends Key = Key> = {
        [P in keyof O]: P extends K ? O[P] | At<O1, P> : O[P];
    } & {};
}
declare module "Object/UnionOf" {
    import { Keys } from "Object/Keys";
    import { At } from "Object/At";
    /**
    Transform an [[Object]] into an [[Union]]
    @param O to transform
    @returns **`any`**
    @example
    ```ts
    ```
    */
    export type UnionOf<O extends object> = At<O, Keys<O>>;
}
declare module "Object/Writable" {
    import { Pick } from "Object/Pick";
    import { Depth } from "Object/_Internal";
    import { MergeFlat } from "Object/Merge";
    import { Key } from "Any/Key";
    import { Implements } from "Any/Implements";
    import { Keys } from "Object/Keys";
    /**
    @hidden
    */
    export type WritableFlat<O> = {
        -readonly [K in keyof O]: O[K];
    };
    /**
    @hidden
    */
    export type WritableDeep<O> = {
        -readonly [K in keyof O]: WritableDeep<O[K]>;
    };
    /**
    @hidden
    */
    type WritablePart<O extends object, depth extends Depth> = {
        'flat': WritableFlat<O>;
        'deep': WritableDeep<O>;
    }[depth];
    /**
    Make some fields of **`O`** writable (deeply or not)
    @param O to make writable
    @param K (?=`any`) to choose fields
    @param depth (?=`'flat'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Writable<O extends object, K extends Key = Key, depth extends Depth = 'flat'> = {
        1: WritablePart<O, depth>;
        0: MergeFlat<WritablePart<Pick<O, K>, depth>, O>;
    }[Implements<Keys<O>, K>] & {};
}
declare module "Object/WritableKeys" {
    import { Equals } from "Any/Equals";
    import { Key } from "Any/Key";
    /**
    @hidden
    */
    export type _WritableKeys<O extends object> = {
        [K in keyof O]-?: {
            1: K;
            0: never;
        }[Equals<{
            -readonly [Q in K]: O[K];
        }, {
            [Q in K]: O[K];
        }>];
    }[keyof O];
    /**
    Get the keys of **`O`** that are writable
    @param O
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type WritableKeys<O extends object> = (O extends unknown ? _WritableKeys<O> : never) & Key;
}
declare module "Object/_api" {
    /** @ignore */ /** */
    import * as P from "Object/P/_api";
    export { P };
    export { Assign } from "Object/Assign";
    export { AssignUp } from "Object/AssignUp";
    export { At } from "Object/At";
    export { Compact } from "Object/Compact";
    export { CompactUp } from "Object/CompactUp";
    export { Compulsory } from "Object/Compulsory";
    export { CompulsoryKeys } from "Object/CompulsoryKeys";
    export { Diff } from "Object/Diff";
    export { Either } from "Object/Either";
    export { Exclude } from "Object/Exclude";
    export { ExcludeKeys } from "Object/ExcludeKeys";
    export { Filter } from "Object/Filter";
    export { FilterKeys } from "Object/FilterKeys";
    export { Has } from "Object/Has";
    export { HasPath } from "Object/HasPath";
    export { Includes } from "Object/Includes";
    export { Intersect } from "Object/Intersect";
    export { IntersectKeys } from "Object/IntersectKeys";
    export { Invert } from "Object/Invert";
    export { Keys } from "Object/Keys";
    export { Merge } from "Object/Merge";
    export { MergeUp } from "Object/MergeUp";
    export { Modify } from "Object/Modify";
    export { NonNullable } from "Object/NonNullable";
    export { NonNullableKeys } from "Object/NonNullableKeys";
    export { Nullable } from "Object/Nullable";
    export { NullableKeys } from "Object/NullableKeys";
    export { Object } from "Object/Object";
    export { Omit } from "Object/Omit";
    export { Optional } from "Object/Optional";
    export { OptionalKeys } from "Object/OptionalKeys";
    export { Overwrite } from "Object/Overwrite";
    export { Path } from "Object/Path";
    export { Paths } from "Object/Paths";
    export { PathValid } from "Object/PathValid";
    export { Pick } from "Object/Pick";
    export { Readonly } from "Object/Readonly";
    export { ReadonlyKeys } from "Object/ReadonlyKeys";
    export { Record } from "Object/Record";
    export { Replace } from "Object/Replace";
    export { Required } from "Object/Required";
    export { RequiredKeys } from "Object/RequiredKeys";
    export { Select } from "Object/Select";
    export { SelectKeys } from "Object/SelectKeys";
    export { ListOf } from "Object/ListOf";
    export { Unionize } from "Object/Unionize";
    export { UnionOf } from "Object/UnionOf";
    export { Update } from "Object/Update";
    export { Writable } from "Object/Writable";
    export { WritableKeys } from "Object/WritableKeys";
}
declare module "String/String" {
    /**
    A [[String]]
    @example
    ```ts
    type string0 = "hello"
    type string1 = "world"
    ```
    */
    export type String = string;
}
declare module "String/_api" {
    /** @ignore */ /** */
    export { Format } from "String/Format";
    export { String } from "String/String";
}
declare module "List/Assign" {
    import { Assign as OAssign } from "Object/Assign";
    import { List } from "List/List";
    import { ObjectOf } from "List/ObjectOf";
    import { ListOf } from "Object/ListOf";
    import { Depth } from "Object/_Internal";
    /**
    Assign a list of [[List]] into **`L`** with `Merge` (last-in overrides)
    @param L to assign to
    @param Ls to assign
    @param depth (?=`'flat'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Assign<L extends List, Ls extends List[], depth extends Depth = 'flat'> = ListOf<ObjectOf<OAssign<L, {
        [K in keyof Ls]: ObjectOf<Ls[K] & {}>;
    }, depth>>>;
}
declare module "List/AssignUp" {
    import { AssignUp as OAssignUp } from "Object/AssignUp";
    import { List } from "List/List";
    import { ObjectOf } from "List/ObjectOf";
    import { ListOf } from "Object/ListOf";
    import { Depth } from "Object/_Internal";
    /**
    Assign a list of [[List]] into **`L`** with [[MergeUp]] (last-in combines or overrides)
    @param L to assign to
    @param Ls to assign
    @param depth (?=`'flat'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type AssignUp<L extends List, Ls extends List<List>, depth extends Depth = 'flat'> = ListOf<ObjectOf<OAssignUp<L, {
        [K in keyof Ls]: ObjectOf<Ls[K] & {}>;
    }, depth>>>;
}
declare module "List/At" {
    import { At as OAt } from "Object/At";
    import { Key } from "Any/Key";
    import { List } from "List/List";
    import { Boolean } from "Boolean/Boolean";
    /**
    Get in **`L`** the type of an entry of key **`K`**
    @param L to extract from
    @param K to extract at
    @param strict (?=`1`) `0` to work with unions
    @returns **`any`**
    @example
    */
    export type At<L extends List, K extends Key, strict extends Boolean = 1> = OAt<L, K, strict>;
}
declare module "List/Compact" {
    import { Compact as OCompact } from "Object/Compact";
    import { List } from "List/List";
    import { ObjectOf } from "List/ObjectOf";
    import { ListOf } from "Object/ListOf";
    import { Depth } from "Object/_Internal";
    /**
    Merge a list of [[List]] into **`L`** with `Merge` (last-in completes)
    @param L to assign to
    @param Ls to assign
    @param depth (?=`'flat'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Compact<L extends List, Ls extends List[], depth extends Depth = 'flat'> = ListOf<ObjectOf<OCompact<L, {
        [K in keyof Ls]: ObjectOf<Ls[K] & {}>;
    }, depth>>>;
}
declare module "List/CompactUp" {
    import { CompactUp as OCompactUp } from "Object/CompactUp";
    import { List } from "List/List";
    import { ObjectOf } from "List/ObjectOf";
    import { ListOf } from "Object/ListOf";
    import { Depth } from "Object/_Internal";
    /**
    Merge a list of [[List]] into **`L`** with [[MergeUp]] (last-in combines or completes)
    @param L to assign to
    @param Ls to assign
    @param depth (?=`'flat'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type CompactUp<L extends List, Ls extends List<List>, depth extends Depth = 'flat'> = ListOf<ObjectOf<OCompactUp<L, {
        [K in keyof Ls]: ObjectOf<Ls[K] & {}>;
    }, depth>>>;
}
declare module "List/Compulsory" {
    import { Depth } from "Object/_Internal";
    import { Compulsory as OCompulsory } from "Object/Compulsory";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    import { Key } from "Any/Key";
    /**
    Make **`L`** compulsory (deeply or not)
    @param L to make compulsory
    @param depth (?=`'flat'`) to do it deeply
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Compulsory<L extends List, depth extends Depth = 'flat'> = Cast<OCompulsory<L, Key, depth>, List>;
}
declare module "List/CompulsoryKeys" {
    import { Compulsory as OCompulsory } from "Object/Compulsory";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Get the keys of **`L`** that are compulsory
    @param L
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type CompulsoryKeys<L extends List> = OCompulsory<ObjectOf<L>>;
}
declare module "List/Diff" {
    import { Diff as ODiff } from "Object/Diff";
    import { ListOf } from "Object/ListOf";
    import { Match } from "Any/_Internal";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Get a [[List]] that is the difference between **`L`** & **`L1`**
    (**`L`**'s differences have priority over **`L1`**'s if entries overlap)
    (If `match = 'default'`, no type checks are done)
    @param L to check differences with
    @param L1 to check differences against
    @param match (?=`'default'`) to change precision
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Diff<L extends List, L1 extends List, match extends Match = 'default'> = ListOf<ODiff<ObjectOf<L>, ObjectOf<L1>, match>>;
}
declare module "List/Either" {
    import { Key } from "Any/Key";
    import { Either as OEither } from "Object/Either";
    import { ObjectOf } from "List/ObjectOf";
    import { _ListOf } from "Object/ListOf";
    import { List } from "List/List";
    import { Boolean } from "Boolean/Boolean";
    import { NumberOf } from "Any/_Internal";
    /**
    Split **`L`** into a [[Union]] with **`K`** keys in such a way that none of
    the keys are ever present with one another within the different unions.
    @param L to split
    @param K to split with
    @param strict (?=`1`) to force excess property checks https://github.com/microsoft/TypeScript/issues/20863
    @returns [[Union]]
    @example
    ```ts
    ```
    */
    export type Either<L extends List, K extends Key, strict extends Boolean = 1> = OEither<ObjectOf<L>, NumberOf<K>, strict> extends infer OE ? OE extends unknown ? _ListOf<OE & {}> : never : never;
}
declare module "List/Exclude" {
    import { Match } from "Any/_Internal";
    import { ListOf } from "Object/ListOf";
    import { Exclude as OExclude } from "Object/Exclude";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Exclude the entries of **`L1`** out of **`L`**
    (If `match = 'default'`, no type checks are done)
    @param L to remove from
    @param L1 to remove out
    @param match (?=`'default'`) to change precision
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Exclude<L extends List, L1 extends List, match extends Match = 'default'> = ListOf<OExclude<ObjectOf<L>, ObjectOf<L1>, match>>;
}
declare module "List/ExcludeKeys" {
    import { ExcludeKeys as OExcludeKeys } from "Object/ExcludeKeys";
    import { Match } from "Any/_Internal";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Exclude the keys of **`L1`** out of the keys of **`L`**
    (If `match = 'default'`, no type checks are done)
    @param L to remove the keys from
    @param L1 to remove the keys out
    @param match (?=`'default'`) to change precision
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type ExcludeKeys<L extends List, L1 extends List, match extends Match = 'default'> = OExcludeKeys<ObjectOf<L>, ObjectOf<L1>, match>;
}
declare module "List/UnionOf" {
    import { List } from "List/List";
    /**
    Transform a [[List]] into an [[Union]]
    @param L to transform
    @returns **`any`**
    @example
    ```ts
    ```
    */
    export type UnionOf<L extends List> = L[number];
}
declare module "List/KeySet" {
    import { Number } from "Number/Number";
    import { Range } from "Number/Range";
    import { UnionOf } from "List/UnionOf";
    /**
    Create a set of keys
    @param From to start with
    @param To to end with
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type KeySet<From extends Number, To extends Number> = UnionOf<Range<From, To, '->'>>;
}
declare module "List/Extract" {
    import { KeySet } from "List/KeySet";
    import { Number } from "Number/Number";
    import { Pick } from "List/Pick";
    import { List } from "List/List";
    /**
    Pick a range of entries (portion) from **`L`**
    @param L to pick from
    @param From to start with
    @param To to end with
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Extract<L extends List, From extends Number, To extends Number> = Pick<L, KeySet<From, To>>;
}
declare module "List/Filter" {
    import { Filter as OFilter } from "Object/Filter";
    import { ListOf } from "Object/ListOf";
    import { Match } from "Any/_Internal";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Filter out of **`L`** the entries that match **`M`**
    @param L to remove from
    @param M to select entries
    @param match (?=`'default'`) to change precision
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Filter<L extends List, M extends any, match extends Match = 'default'> = ListOf<OFilter<ObjectOf<L>, M, match>>;
}
declare module "List/FilterKeys" {
    import { FilterKeys as OFilterKeys } from "Object/FilterKeys";
    import { Match } from "Any/_Internal";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Filter out the keys of **`L`** which entries match **`M`**
    @param L to remove from
    @param M to select entries
    @param match (?=`'default'`) to change precision
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type FilterKeys<L extends List, M extends any, match extends Match = 'default'> = OFilterKeys<ObjectOf<L>, M, match>;
}
declare module "List/UnNest" {
    import { _Concat } from "List/Concat";
    import { _Append } from "List/Append";
    import { Cast } from "Any/Cast";
    import { Length } from "List/Length";
    import { Iteration } from "Iteration/Iteration";
    import { IterationOf } from "Iteration/IterationOf";
    import { Next } from "Iteration/Next";
    import { Pos } from "Iteration/Pos";
    import { List } from "List/List";
    import { UnionOf } from "List/UnionOf";
    import { Naked } from "List/_Internal";
    import { Extends } from "Any/Extends";
    /**
    @hidden
    */
    type UnNestCheap<L extends List> = (UnionOf<L> extends infer UL ? UL extends unknown ? UL extends List ? UnionOf<UL> : UL : never : never)[] & {};
    /**
    @hidden
    */
    type Flatter<L extends List, LN extends List, I extends Iteration> = L[Pos<I>] extends List ? _Concat<LN, L[Pos<I>]> : _Append<LN, L[Pos<I>]>;
    /**
    @hidden
    */
    type UnNestExact<L extends List, LN extends List = [], I extends Iteration = IterationOf<'0'>> = {
        0: UnNestExact<L, Flatter<L, LN, I>, Next<I>>;
        1: LN;
    }[Extends<Pos<I>, Length<L>>];
    /**
    @hidden
    */
    type __UnNest<L extends List> = number extends Length<L> ? UnNestCheap<L> : UnNestExact<L>;
    /**
    @hidden
    */
    export type _UnNest<L extends List> = __UnNest<Naked<L>> extends infer X ? Cast<X, List> : never;
    /**
    Remove a dimension of **`L`**
    @param L to un-nest
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type UnNest<L extends List> = L extends unknown ? _UnNest<L> : never;
}
declare module "List/Flatten" {
    import { List } from "List/List";
    import { _UnNest } from "List/UnNest";
    import { Cast } from "Any/Cast";
    import { Equals } from "Any/Equals";
    import { Naked } from "List/_Internal";
    /**
    @hidden
    */
    type __Flatten<L extends List, LO extends List = []> = {
        0: __Flatten<_UnNest<L>, L>;
        1: L;
    }[Equals<L, LO> extends 0 ? 0 : 1];
    /**
    @hidden
    */
    export type _Flatten<L extends List> = __Flatten<Naked<L>> extends infer X ? Cast<X, List> : never;
    /**
    Remove all dimensions of **`L`** (10 max)
    @param L to un-nest
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Flatten<L extends List> = L extends unknown ? _Flatten<L> : never;
}
declare module "List/Take" {
    import { Number } from "Number/Number";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Pos } from "Iteration/Pos";
    import { Prepend } from "List/Prepend";
    import { Way } from "Iteration/_Internal";
    import { List } from "List/List";
    import { Prev } from "Iteration/Prev";
    import { Cast } from "Any/Cast";
    import { Naked } from "List/_Internal";
    import { Tail } from "List/Tail";
    import { Extends } from "Any/Extends";
    /**
    starts in reverse from `N` till `N` = 0
    @hidden
    */
    type TakeForth<L extends List, N extends Iteration, I extends Iteration = Prev<N>, LN extends List = []> = {
        0: TakeForth<L, N, Prev<I>, Prepend<LN, L[Pos<I>]>>;
        1: LN;
    }[Extends<-1, Pos<I>>];
    /**
    starts in reverse from the end till `N` = 0
    @hidden
    */
    type TakeBack<L extends List, N extends Iteration> = {
        0: TakeBack<Tail<L>, Prev<N>>;
        1: L;
    }[Extends<0, Pos<N>>];
    /**
    @hidden
    */
    type __Take<L extends List, N extends Iteration, way extends Way> = {
        '->': TakeForth<L, N>;
        '<-': TakeBack<L, N>;
    }[way];
    /**
    @hidden
    */
    export type _Take<L extends List, N extends Number, way extends Way = '->'> = __Take<Naked<L>, IterationOf<N>, way> extends infer X ? Cast<X, List> : never;
    /**
    Extract **`N`** entries out of **`L`**
    @param L to extract from
    @param N to extract out
    @param way (?=`'->'`) to extract from end
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Take<L extends List, N extends Number, way extends Way = '->'> = L extends unknown ? N extends unknown ? _Take<L, N, way> : never : never;
}
declare module "List/Group" {
    import { Number } from "Number/Number";
    import { _Drop } from "List/Drop";
    import { _Take } from "List/Take";
    import { Cast } from "Any/Cast";
    import { Prepend } from "List/Prepend";
    import { _Reverse } from "List/Reverse";
    import { List } from "List/List";
    import { Naked } from "List/_Internal";
    /**
    @hidden
    */
    type __Group<L extends List, N extends Number, LN extends List = []> = {
        0: __Group<_Drop<L, N>, N, Prepend<LN, _Take<L, N>>>;
        1: _Reverse<LN>;
    }[L extends List<never> ? 1 : 0];
    /**
    @hidden
    */
    export type _Group<L extends List, N extends Number> = __Group<Naked<L>, N> extends infer X ? Cast<X, List> : never;
    /**
    Split **`L`** into sub-[[List]]s every **`N`**
    @param L to group
    @param N to split at
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Group<L extends List, N extends Number> = L extends unknown ? N extends unknown ? _Group<L, N> : never : never;
}
declare module "List/Has" {
    import { Match, NumberOf } from "Any/_Internal";
    import { Has as OHas } from "Object/Has";
    import { Key } from "Any/Key";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Check whether **`L`** has a entry of key **`K`** that matches **`M`**
    @param L to be inspected
    @param K to choose entry
    @param M (?=`any`) to check entry type
    @param match (?=`'default'`) to change precision
    @returns [[Boolean]]
    @example
    ```ts
    ```
    */
    export type Has<L extends List, K extends Key, M extends any = any, match extends Match = 'default'> = OHas<ObjectOf<L>, NumberOf<K>, M, match>;
}
declare module "List/HasPath" {
    import { HasPath as OHasPath } from "Object/HasPath";
    import { Match } from "Any/_Internal";
    import { Key } from "Any/Key";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Check whether **`L`** has nested entries that match **`M`**
    @param L to be inspected
    @param Path to be followed
    @param M (?=`any`) to check entry type
    @param match (?=`'default'`) to change precision
    @returns [[Boolean]]
    @example
    ```ts
    ```
    */
    export type HasPath<L extends List, Path extends List<Key>, M extends any = any, match extends Match = 'default'> = OHasPath<ObjectOf<L>, Path, M, match>;
}
declare module "List/Includes" {
    import { Match } from "Any/_Internal";
    import { Includes as OIncludes } from "Object/Includes";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Check whether **`L`** has entries that match **`M`**
    @param L to be inspected
    @param M to check entry type
    @param match (?=`'default'`) to change precision
    @returns [[Boolean]]
    @example
    ```ts
    ```
    */
    export type Includes<L extends List, M extends any, match extends Match = 'default'> = OIncludes<ObjectOf<L>, M, match>;
}
declare module "List/Intersect" {
    import { Intersect as OIntersect } from "Object/Intersect";
    import { Match } from "Any/_Internal";
    import { ListOf } from "Object/ListOf";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Get the intersecting entries of **`L`** & **`L1`**
    (If `match = 'default'`, no type checks are done)
    @param L to check similarities with
    @param L1 to check similarities against
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Intersect<L extends List, L1 extends List, match extends Match = 'default'> = ListOf<OIntersect<ObjectOf<L>, ObjectOf<L1>, match>>;
}
declare module "List/IntersectKeys" {
    import { Match } from "Any/_Internal";
    import { IntersectKeys as OIntersectKeys } from "Object/IntersectKeys";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Get the intersecting entries of **`L`** & **`L1`**
    (If `match = 'default'`, no type checks are done)
    @param L to check similarities with
    @param L1 to check similarities against
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type IntersectKeys<L extends List, L1 extends List, match extends Match = 'default'> = OIntersectKeys<ObjectOf<L>, L1, match>;
}
declare module "List/Longest" {
    import { Exclude } from "Union/Exclude";
    import { List } from "List/List";
    import { Keys } from "List/Keys";
    /**
    Get the longest [[List]] of **`L`** & **`L1`**
    (**`L`** has priority if both lengths are equal)
    @param L to compare length
    @param L1 to compare length
    @returns **`L`** or **`L1`**
    @example
    ```ts
    ```
    */
    export type Longest<L extends List, L1 extends List> = [Exclude<Keys<L1>, Keys<L>>] extends [never] ? L : L1;
}
declare module "List/Merge" {
    import { At } from "Object/At";
    import { Depth } from "Object/_Internal";
    import { ObjectOf } from "List/ObjectOf";
    import { ListOf } from "Object/ListOf";
    import { Length } from "List/Length";
    import { Kind } from "Any/Kind";
    import { List } from "List/List";
    /**
    @hidden
    */
    type MergeFlatTuple<L extends List, L1 extends List> = ListOf<ObjectOf<{
        [K in keyof L | keyof L1]: [At<L, K>] extends [never] ? At<L1, K> : At<L, K>;
    }>>;
    /**
    @hidden
    */
    type MergeFlatArray<L extends List, L1 extends List> = (L | L1) extends (infer L)[] ? L[] : never;
    /**
    @hidden
    */
    export type MergeFlat<L extends List, L1 extends List> = number extends Length<L | L1> ? MergeFlatArray<L, L1> : MergeFlatTuple<L, L1>;
    /**
    @hidden
    */
    export type MergeDeep<O, O1> = Kind<(O | O1)> extends 'array' ? MergeFlat<O & [], O1 & []> extends infer M ? {
        [K in keyof M]: MergeDeep<M[K], At<O1 & [], K>>;
    } & {} : never : O;
    /**
    Complete the fields of **`O`** with the ones of **`O1`**
    ('deep' option will skip any nullable object to be merged)
    @param O to complete
    @param O1 to copy from
    @param depth (?=`'flat'`) to do it deeply
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Merge<L extends List, L1 extends List, depth extends Depth = 'flat'> = {
        'flat': MergeFlat<L, L1>;
        'deep': MergeDeep<L, L1>;
    }[depth];
}
declare module "List/Modify" {
    import { At } from "List/At";
    import { Replace } from "Union/Replace";
    import { x } from "Any/x";
    import { Exclude } from "Union/Exclude";
    import { List } from "List/List";
    /**
    Modify **`L`** with **`LMod`** & the [[x]] placeholder
    @param L to copy from
    @param LMod to copy to
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Modify<L extends List, LMod extends List> = {
        [K in keyof LMod]: Replace<LMod[K], x, Exclude<At<L, K>, undefined>>;
    } & {};
}
declare module "List/NonNullableKeys" {
    import { NonNullableKeys as ONonNullableKeys } from "Object/NonNullableKeys";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Get the keys of **`L`** that are non-nullable
    @param L
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type NonNullableKeys<L extends List> = ONonNullableKeys<ObjectOf<L>>;
}
declare module "List/Nullable" {
    import { Key } from "Any/Key";
    import { Cast } from "Any/Cast";
    import { Implements } from "Any/Implements";
    import { Depth } from "Object/_Internal";
    import { Nullable as ONullable } from "Object/Nullable";
    import { ListOf } from "Object/ListOf";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    import { Keys } from "List/Keys";
    import { NumberOf } from "Any/_Internal";
    /**
    Make some entries of **`L`** nullable (deeply or not)
    @param L to make nullable
    @param K (?=`any`) to choose fields
    @param depth (?=`'flat'`) to do it deeply
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Nullable<L extends List, K extends Key = Key, depth extends Depth = 'flat'> = {
        1: Cast<ONullable<L, Key, depth>, List>;
        0: ListOf<ONullable<ObjectOf<L>, NumberOf<K>, depth>>;
    }[Implements<Keys<L>, K>] & {};
}
declare module "List/NullableKeys" {
    import { NullableKeys as ONullableKeys } from "Object/NullableKeys";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Get the keys of **`L`** that are nullable
    @param L
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type NullableKeys<L extends List> = ONullableKeys<ObjectOf<L>>;
}
declare module "List/Optional" {
    import { Optional as OOptional } from "Object/Optional";
    import { Depth } from "Object/_Internal";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    import { Key } from "Any/Key";
    /**
    Make **`L`** optional (deeply or not)
    @param L to make optional
    @param depth (?=`'flat'`) to do it deeply
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Optional<L extends List, depth extends Depth = 'flat'> = Cast<OOptional<L, Key, depth>, List>;
}
declare module "List/OptionalKeys" {
    import { OptionalKeys as OOptionalKeys } from "Object/OptionalKeys";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Get the keys of **`L`** that are optional
    @param L
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type OptionalKeys<L extends List> = OOptionalKeys<ObjectOf<L>>;
}
declare module "List/Path" {
    import { Path as OPath } from "Object/Path";
    import { Key } from "Any/Key";
    import { List } from "List/List";
    /**
    Get in **`L`** the type of nested properties
    @param L to be inspected
    @param Path to be followed
    @returns **`any`**
    @example
    ```ts
    ```
    */
    export type Path<L extends List, Path extends List<Key>> = OPath<L, Path>;
}
declare module "List/Paths" {
    import { Paths as OPaths } from "Object/Paths";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Get all the possible paths of **`L`**
    (⚠️ this won't work with circular-refs)
    @param L to be inspected
    @returns **`string[]`**
    @example
    ```ts
    ```
    */
    export type Paths<L extends List> = OPaths<ObjectOf<L>>;
}
declare module "List/PathValid" {
    import { PathValid as OPathValid } from "Object/PathValid";
    import { Key } from "Any/Key";
    import { List } from "List/List";
    /**
    Replaces invalid parts of a path with `never`
    @param L to be inspected
    @param Path to be validated
    @returns **`Index[]`**
    @example
    ```ts
    import {A, L, O} from 'ts-toolbelt'
    
    // Get a property in an array `t` at any depth with `path`
    // `A.Cast<P, L.PathValid<L, P>>` makes sure `path` is valid
    const getAt = <
    L extends L.List,
    P extends L.List<A.Index>
    >(t: L, path: A.Cast<P, L.PathValid<L, P>>): L.Path<L, P> => {
        let valueAt = t
    
        for (const p of path)
            valueAt = valueAt[p]
    
        return valueAt as any
    }
    
    const test0 = getAt([[[1]]] as const, [0, 0] as const) // [1]
    const test1 = getAt([[[1]]] as const, [1] as const)    // error
    ```
    */
    export type PathValid<L extends List, Path extends List<Key>> = OPathValid<L, Path>;
}
declare module "List/Pop" {
    import { _Omit } from "List/Omit";
    import { List } from "List/List";
    import { LastIndex } from "List/LastIndex";
    import { Naked } from "List/_Internal";
    /**
    @hidden
    */
    export type _Pop<L extends List> = _Omit<L, LastIndex<Naked<L>, 's'>>;
    /**
    Remove the last element out of **`L`**
    @param L to remove from
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Pop<L extends List> = L extends unknown ? _Pop<L> : never;
}
declare module "List/Readonly" {
    import { Depth } from "Object/_Internal";
    import { Readonly as OReadonly } from "Object/Readonly";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    import { Key } from "Any/Key";
    /**
    Make **`L`** readonly (deeply or not)
    @param L to make readonly
    @param depth (?=`'flat'`) to do it deeply
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Readonly<L extends List, depth extends Depth = 'flat'> = Cast<OReadonly<L, Key, depth>, List>;
}
declare module "List/ReadonlyKeys" {
    import { ReadonlyKeys as OReadonlyKeys } from "Object/ReadonlyKeys";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Get the keys of **`L`** that are readonly
    @param L
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type ReadonlyKeys<L extends List> = OReadonlyKeys<ObjectOf<L>>;
}
declare module "List/Remove" {
    import { Number } from "Number/Number";
    import { KeySet } from "List/KeySet";
    import { Omit } from "List/Omit";
    import { List } from "List/List";
    /**
    Remove out of **`L`** a range of entries
    @param L to remove from
    @param From to start with
    @param To to end with
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Remove<L extends List, From extends Number, To extends Number> = Omit<L, KeySet<From, To>>;
}
declare module "List/Replace" {
    import { Replace as OReplace } from "Object/Replace";
    import { Match } from "Any/_Internal";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    /**
    Update with **`A`** the entries of **`L`** that match **`M`**
    @param O to update
    @param M to select fields
    @param A to update with
    @param match (?=`'default'`) to change precision
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Replace<L extends List, M extends any, A extends any, match extends Match = 'default'> = Cast<OReplace<L, M, A, match>, List>;
}
declare module "List/Required" {
    import { Depth } from "Object/_Internal";
    import { Required as ORequired } from "Object/Required";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    import { Key } from "Any/Key";
    /**
    Make **`L`** required (deeply or not)
    @param L to make required
    @param depth (?=`'flat'`) to do it deeply
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Required<L extends List, depth extends Depth = 'flat'> = Cast<ORequired<L, Key, depth>, List>;
}
declare module "List/RequiredKeys" {
    import { RequiredKeys as ORequiredKeys } from "Object/RequiredKeys";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Get the keys of **`L`** that are readonly
    @param L
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type RequiredKeys<L extends List> = ORequiredKeys<ObjectOf<L>>;
}
declare module "List/Select" {
    import { Match } from "Any/_Internal";
    import { Select as OSelect } from "Object/Select";
    import { ListOf } from "Object/ListOf";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Extract the entries of **`L`** that match **`M`**
    @param L to extract from
    @param M to select entries
    @param match (?=`'default'`) to change precision
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Select<L extends List, M extends any, match extends Match = 'default'> = ListOf<OSelect<ObjectOf<L>, M, match>>;
}
declare module "List/SelectKeys" {
    import { Match } from "Any/_Internal";
    import { SelectKeys as OSelectKeys } from "Object/SelectKeys";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Get the keys of **`L`** which entries match **`M`**
    @param L to extract from
    @param M to select entries
    @param match (?=`'default'`) to change precision
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type SelectKeys<L extends List, M extends any, match extends Match = 'default'> = OSelectKeys<ObjectOf<L>, M, match>;
}
declare module "List/Shortest" {
    import { Exclude } from "Union/Exclude";
    import { List } from "List/List";
    import { Keys } from "List/Keys";
    /**
    Get the shortest [[List]] of **`L`** & **`L1`**
    (**`L`** has priority if both lengths are equal)
    @param L to compare length
    @param L1 to compare length
    @returns **`L`** or **`L1`**
    @example
    ```ts
    ```
    */
    export type Shortest<L extends List, L1 extends List> = [Exclude<Keys<L>, Keys<L1>>] extends [never] ? L : L1;
}
declare module "List/Unionize" {
    import { Key } from "Any/Key";
    import { List } from "List/List";
    import { At } from "Object/At";
    import { Format } from "String/_api";
    /**
    Make the fields of **`L`** union the ones of **`L1`**
    @param L to union from
    @param L1 to union with
    @param K (?=`any`) to do choose fields
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Unionize<L extends List, L1 extends List, K extends Key = Key> = {
        [P in keyof L]: P extends K ? L[P] | At<L1, P extends string ? Format<P, 'n'> : P> : L[P];
    } & {};
}
declare module "List/Writable" {
    import { Depth } from "Object/_Internal";
    import { Writable as OWritable } from "Object/Writable";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    import { Key } from "Any/Key";
    /**
    Make **`L`** writable (deeply or not)
    @param L to make writable
    @param depth (?=`'flat'`) to do it deeply
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Writable<L extends List, depth extends Depth = 'flat'> = Cast<OWritable<L, Key, depth>, List>;
}
declare module "List/WritableKeys" {
    import { WritableKeys as OWritableKeys } from "Object/WritableKeys";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /**
    Get the keys of **`O`** that are writable
    @param O
    @returns [[Key]]
    @example
    ```ts
    ```
    */
    export type WritableKeys<L extends List> = OWritableKeys<ObjectOf<L>>;
}
declare module "List/Zip" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Prepend } from "List/Prepend";
    import { Next } from "Iteration/Next";
    import { Length } from "List/Length";
    import { Pos } from "Iteration/Pos";
    import { _Reverse } from "List/Reverse";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    import { Naked } from "List/_Internal";
    import { Extends } from "Any/Extends";
    /**
    @hidden
    */
    type __Zip<L extends List, L1 extends List, LN extends List = [], I extends Iteration = IterationOf<'0'>> = {
        0: __Zip<L, L1, Prepend<LN, [L[Pos<I>], L1[Pos<I>]]>, Next<I>>;
        1: _Reverse<LN>;
    }[Extends<Pos<I>, Length<L>>];
    /**
    @hidden
    */
    export type _Zip<L extends List, L1 extends List> = __Zip<Naked<L>, Naked<L1>> extends infer X ? Cast<X, List> : never;
    /**
    Pair up the entries of **`L`** with **`L1`**
    @param L to pair up
    @param L1 to pair up with
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type Zip<L extends List, L1 extends List> = L extends unknown ? L1 extends unknown ? _Zip<L, L1> : never : never;
}
declare module "List/ZipObj" {
    import { Length } from "List/Length";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Cast } from "Any/Cast";
    import { MergeFlat } from "Object/Merge";
    import { Record } from "Object/Record";
    import { Key } from "Any/Key";
    import { List } from "List/List";
    import { Naked } from "List/_Internal";
    import { Extends } from "Any/Extends";
    /**
    @hidden
    */
    type __ZipObj<LKeys extends List<Key>, LFields extends List, O extends object = {}, I extends Iteration = IterationOf<'0'>> = {
        0: __ZipObj<LKeys, LFields, MergeFlat<O, Record<LKeys[Pos<I>], LFields[Pos<I>]>>, Next<I>>;
        1: O;
    }[Extends<Pos<I>, Length<LKeys>>];
    /**
    @hidden
    */
    export type _ZipObj<LKeys extends List<Key>, LFields extends List> = __ZipObj<Naked<LKeys>, Naked<LFields>> extends infer X ? Cast<X, object> : never;
    /**
    Create an [[Object]] from [[List]]s of keys & fields
    @param LKeys its keys
    @param LFields its fields
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type ZipObj<LKeys extends List<Key>, LFields extends List> = LKeys extends unknown ? LFields extends unknown ? _ZipObj<LKeys, LFields> : never : never;
}
declare module "List/_api" {
    /** @ignore */ /** */
    export { Append } from "List/Append";
    export { Assign } from "List/Assign";
    export { AssignUp } from "List/AssignUp";
    export { At } from "List/At";
    export { Compact } from "List/Compact";
    export { CompactUp } from "List/CompactUp";
    export { Compulsory } from "List/Compulsory";
    export { CompulsoryKeys } from "List/CompulsoryKeys";
    export { Concat } from "List/Concat";
    export { Diff } from "List/Diff";
    export { Drop } from "List/Drop";
    export { Either } from "List/Either";
    export { Exclude } from "List/Exclude";
    export { ExcludeKeys } from "List/ExcludeKeys";
    export { Extract } from "List/Extract";
    export { Filter } from "List/Filter";
    export { FilterKeys } from "List/FilterKeys";
    export { Flatten } from "List/Flatten";
    export { Group } from "List/Group";
    export { Has } from "List/Has";
    export { HasPath } from "List/HasPath";
    export { Head } from "List/Head";
    export { Includes } from "List/Includes";
    export { Intersect } from "List/Intersect";
    export { IntersectKeys } from "List/IntersectKeys";
    export { Keys } from "List/Keys";
    export { KeySet } from "List/KeySet";
    export { Last } from "List/Last";
    export { LastIndex } from "List/LastIndex";
    export { Length } from "List/Length";
    export { Longest } from "List/Longest";
    export { Merge } from "List/Merge";
    export { Modify } from "List/Modify";
    export { NonNullable } from "List/NonNullable";
    export { NonNullableKeys } from "List/NonNullableKeys";
    export { Nullable } from "List/Nullable";
    export { NullableKeys } from "List/NullableKeys";
    export { ObjectOf } from "List/ObjectOf";
    export { Omit } from "List/Omit";
    export { Optional } from "List/Optional";
    export { OptionalKeys } from "List/OptionalKeys";
    export { Overwrite } from "List/Overwrite";
    export { Path } from "List/Path";
    export { Paths } from "List/Paths";
    export { PathValid } from "List/PathValid";
    export { Pick } from "List/Pick";
    export { Pop } from "List/Pop";
    export { Prepend } from "List/Prepend";
    export { Readonly } from "List/Readonly";
    export { ReadonlyKeys } from "List/ReadonlyKeys";
    export { Remove } from "List/Remove";
    export { Repeat } from "List/Repeat";
    export { Replace } from "List/Replace";
    export { Required } from "List/Required";
    export { RequiredKeys } from "List/RequiredKeys";
    export { Reverse } from "List/Reverse";
    export { Select } from "List/Select";
    export { SelectKeys } from "List/SelectKeys";
    export { Shortest } from "List/Shortest";
    export { Tail } from "List/Tail";
    export { Take } from "List/Take";
    export { List } from "List/List";
    export { Unionize } from "List/Unionize";
    export { UnionOf } from "List/UnionOf";
    export { UnNest } from "List/UnNest";
    export { Update } from "List/Update";
    export { Writable } from "List/Writable";
    export { WritableKeys } from "List/WritableKeys";
    export { Zip } from "List/Zip";
    export { ZipObj } from "List/ZipObj";
}
declare module "Union/Diff" {
    import { Exclude } from "Union/Exclude";
    import { Union } from "Union/Union";
    /**
    Get an [[Union]] that is the difference between **`U1`** & **`U2`**
    @param U1 to check differences with
    @param U2 to check differences against
    @returns [[Union]]
    @example
    ```ts
    ```
    */
    export type Diff<U1 extends Union, U2 extends Union> = Exclude<U1, U2> | Exclude<U2, U1>;
}
declare module "Union/Filter" {
    import { Exclude } from "Union/Exclude";
    import { Union } from "Union/Union";
    /**
    Remove **`M`** out of **`U`**
    @param U to remove from
    @param M to remove out
    @returns [[Union]]
    @example
    ```ts
    ```
    */
    export type Filter<U extends Union, M extends Union> = Exclude<U, M>;
}
declare module "Union/Last" {
    import { IntersectOf } from "Union/IntersectOf";
    import { Union } from "Union/Union";
    /**
    Get the last item within an [[Union]]
    (⚠️ it might not preserve order)
    @param U
    @returns **any**
    @example
    ```ts
    ```
    */
    export type Last<U extends Union> = IntersectOf<U extends unknown ? (x: U) => void : never> extends (x: infer P) => void ? P : never;
}
declare module "Union/Merge" {
    import { At } from "Object/At";
    import { Overwrite } from "Object/Overwrite";
    import { Compute } from "Any/Compute";
    import { IntersectOf } from "Union/IntersectOf";
    import { Strict } from "Union/Strict";
    /**
    @hidden
    */
    type _Merge<U extends object> = IntersectOf<Overwrite<U, {
        [K in keyof U]-?: U extends unknown ? At<U, K> : never;
    }>>;
    /**
    Merge a [[Union]] of [[Object]]s into a single one
    @param U to merge
    @returns [[Object]]
    @example
    ```ts
    ```
    */
    export type Merge<U extends object> = Compute<_Merge<Strict<U>>>;
}
declare module "Union/Pop" {
    import { Exclude } from "Union/Exclude";
    import { Last } from "Union/Last";
    import { Union } from "Union/Union";
    /**
    Remove an item out of **`U`**
    (⚠️ it might not preserve order)
    @param U to remove from
    @returns [[Union]]
    @example
    ```ts
    ```
    */
    export type Pop<U extends Union> = Exclude<U, Last<U>>;
}
declare module "Union/ListOf" {
    import { Last } from "Union/Last";
    import { Prepend } from "List/Prepend";
    import { Exclude } from "Union/Exclude";
    import { List } from "List/List";
    import { Union } from "Union/Union";
    import { Cast } from "Any/Cast";
    import { Extends } from "Any/Extends";
    /**
    @hidden
    */
    type _ListOf<U, LN extends List = [], LastU = Last<U>> = {
        0: _ListOf<Exclude<U, LastU>, Prepend<LN, LastU>>;
        1: LN;
    }[Extends<[U], [never]>];
    /**
    Transform a [[Union]] into a [[List]]
    (⚠️ it might not preserve order)
    @param U to transform
    @returns [[List]]
    @example
    ```ts
    ```
    */
    export type ListOf<U extends Union> = _ListOf<U> extends infer X ? Cast<X, List> : never;
}
declare module "Union/_api" {
    /** @ignore */ /** */
    export { Diff } from "Union/Diff";
    export { Exclude } from "Union/Exclude";
    export { Filter } from "Union/Filter";
    export { Has } from "Union/Has";
    export { Intersect } from "Union/Intersect";
    export { IntersectOf } from "Union/IntersectOf";
    export { Keys } from "Union/Keys";
    export { Last } from "Union/Last";
    export { Merge } from "Union/Merge";
    export { NonNullable } from "Union/NonNullable";
    export { Nullable } from "Union/Nullable";
    export { Pop } from "Union/Pop";
    export { Replace } from "Union/Replace";
    export { Select } from "Union/Select";
    export { Strict } from "Union/Strict";
    export { ListOf } from "Union/ListOf";
}
declare module "index" {
    /** @ignore */ /** */
    import * as Test from "Test";
    import * as A from "Any/_api";
    import * as B from "Boolean/_api";
    import * as C from "Class/_api";
    import * as F from "Function/_api";
    import * as I from "Iteration/_api";
    import * as M from "Misc/_api";
    import * as N from "Number/_api";
    import * as O from "Object/_api";
    import * as S from "String/_api";
    import * as T from "List/_api";
    import * as L from "List/_api";
    import * as U from "Union/_api";
    import * as Any from "Any/_api";
    import * as Boolean from "Boolean/_api";
    import * as Class from "Class/_api";
    import * as Function from "Function/_api";
    import * as Iteration from "Iteration/_api";
    import * as Misc from "Misc/_api";
    import * as Number from "Number/_api";
    import * as Object from "Object/_api";
    import * as String from "String/_api";
    import * as Tuple from "List/_api";
    import * as List from "List/_api";
    import * as Union from "Union/_api";
    export { Test, A, Any, B, Boolean, C, Class, F, Function, I, Iteration, L, List, M, Misc, N, Number, O, Object, S, String, T, Tuple, U, Union, };
}

declare module 'ts-toolbelt' {
    import main = require('index');
    export = main;
}

